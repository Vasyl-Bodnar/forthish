// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=exe, use-js-string=true, version=5.9.1
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   "use strict";
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   var jsoo_static_env = {};
   function jsoo_sys_getenv(n){
    if(jsoo_static_env[n]) return jsoo_static_env[n];
    var process = globalThis.process;
    if(process && process.env && process.env[n] !== undefined)
     return process.env[n];
    if(globalThis.jsoo_env && typeof globalThis.jsoo_env[n] === "string")
     return globalThis.jsoo_env[n];
   }
   var caml_record_backtrace_env_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] === "b"){
         caml_record_backtrace_env_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_env_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var
    caml_record_backtrace_runtime_flag = caml_record_backtrace_env_flag,
    caml_global_data = [0];
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] === 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_env_flag
            && caml_record_backtrace_runtime_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) === 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s === 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! Array.isArray(arg))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length !== arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout === 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a === b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 === 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im === re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 === 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout !== b.layout || this.kind !== b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length !== b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] !== b.dims[i])
       return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x !== y){
          if(! total) return Number.NaN;
          if(! Number.isNaN(x)) return 1;
          if(! Number.isNaN(y)) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(Array.isArray(arg) && arg.length === 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element !== data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout === 0 && dims.length === 1 && size_per_element === 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len === 0) return 0;
    if(i2 === 0 && (len >= s2.l || s2.t === 2 && len >= s2.c.length)){
     s2.c =
      s1.t === 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else if(s2.t === 2 && i2 === s2.c.length){
     s2.c +=
      s1.t === 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else{
     if(s2.t !== 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t === 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function caml_str_repeat(n, s){
    if(n === 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n === 0) return r;
     s += s;
     l++;
     if(l === 9) s.slice(0, 1);
    }
   }
   function caml_convert_string_to_bytes(s){
    if(s.t === 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.slice(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j === l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) === 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3ff));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.slice(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
       case 8:
        return this.c;
       case 4:
       case 2:
        caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)) this.t = 9; else this.t = 8; return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t === 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t === 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_jsbytes_of_string(x){return x;}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      case 0:
       return s.c.charCodeAt(i);
      case 2:
       if(i >= s.c.length) return 0; return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t !== 4){
     if(i === s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 === s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d === 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length === 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_classify_float(x){
    if(Number.isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x !== 0) return 1;
     return 2;
    }
    return Number.isNaN(x) ? 4 : 3;
   }
   function caml_is_continuation_tag(t){return t === 245 ? 1 : 0;}
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474e307) === 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x === 0) return Number.NEGATIVE_INFINITY;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! Number.isFinite(x)){
     if(Number.isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var
     sign =
       x === 0 && 1 / x === Number.NEGATIVE_INFINITY
        ? 0x8000
        : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp === 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom === "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp === 2047)
     return (lo | mi | hi & 0xf) === 0
             ? hi
               & 0x8000
               ? Number.NEGATIVE_INFINITY
               : Number.POSITIVE_INFINITY
             : Number.NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name === "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim === 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi !== 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) !== 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large"); break;
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {_j:
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       _i: {deserialize: caml_int32_unmarshal, fixed_length: 4},
       _n: {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       _bigarray:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       _bigarr02:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && Number.isNaN(x)) return swap;
     if(Number.isNaN(+ x)) return + x;
     if((x | 0) !== 0) return x | 0;
    }
    return swap;
   }
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(Array.isArray(a) && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag === 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a === "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a === "function")
     return 1247;
    else if(typeof a === "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a === b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a === 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b === 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a === 1000){
        if(tag_b === 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b === 1000){
        if(tag_a === 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]) | 0;
         if(x !== 0) return x;
         break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b) | 0;
          if(x !== 0) return x;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp !== caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b){
          if(! total) return Number.NaN;
          if(! Number.isNaN(a)) return 1;
          if(! Number.isNaN(b)) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b) return total ? 1 : Number.NaN;
         break;
        case 1251:
         if(a !== b) return total ? 1 : Number.NaN; break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length !== b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length === 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_convert_raw_backtrace(){return [0];}
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_div(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_compare_and_set(old, n){
    if(caml_domain_dls !== old) return 0;
    caml_domain_dls = n;
    return 1;
   }
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) === 0);}
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i === 0 && (l >= s.l || s.t === 2 && l >= s.c.length))
      if(c === 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l === s.l ? 0 : 2;
      }
     else{
      if(s.t !== 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
        break;
       case "d":
       case "i":
        f.signedconv = true; f.base = 10; break;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle !== "-")) len++;
    if(f.alternate){if(f.base === 8) len += 1; if(f.base === 16) len += 2;}
    var buffer = "";
    if(f.justify === "+" && f.filler === " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle !== "-") buffer += f.signstyle;
    if(f.alternate && f.base === 8) buffer += "0";
    if(f.alternate && f.base === 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify === "+" && f.filler === "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify === "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = Number.parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x === 0 && 1 / x === Number.NEGATIVE_INFINITY){f.sign = - 1; x = - x;}
    if(Number.isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! Number.isFinite(x)){s = "inf"; f.filler = " ";}
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) === "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) === "0") i--;
         if(s.charAt(i) === ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) === "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) === "0") i--;
          if(s.charAt(i) === ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) === "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.slice(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = device.length > 0 && device.charAt(1) !== ":";
     if(result[2] || isUnc){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.slice(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split(/[/\\]/),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.slice(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j === l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 === l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.slice(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t !== 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_ml_bytes_length(s){return s.l;}
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name, do_not_lookup){
     if(name === "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     if(! do_not_lookup) this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name === "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name === "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i === a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name === "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     if(! this.exists(name, true))
      caml_raise_sys_error(name + ": No such file or directory");
     delete this.content[name];
     return 0;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(Array.isArray(content))
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function MlNodeFd(fd, flags){
    this.fs = require("node:fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){
    this.fs = require("node:fs");
    this.root = root;
   }
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{this.fs.unlinkSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("node:constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) === 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.jsoo_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.jsoo_fs_tmp = [];
    return 0;
   }
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      case 2:
       caml_convert_string_to_bytes(s); return s.c;
      default: return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(Array.isArray(v) && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3fffffff;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! Number.isFinite(x)){
     if(Number.isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var
     sign = x === 0 && 1 / x === Number.NEGATIVE_INFINITY ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x === 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.slice(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_parse_sign_and_base(s){
    var
     i = 0,
     len = caml_ml_string_length(s),
     base = 10,
     sign = 1,
     signedness = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) === 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        signedness = 0; base = 16; i += 2; break;
       case 111:
       case 79:
        signedness = 0; base = 8; i += 2; break;
       case 98:
       case 66:
        signedness = 0; base = 2; i += 2; break;
       case 117:
       case 85:
        signedness = 0; i += 2; break;
     }
    return [i, sign, base, signedness];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i !== len) caml_failwith("int_of_string");
    res = sign * res;
    if(signedness && (res | 0) !== res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   var caml_callback = caml_call_gen;
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] === o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return Array.isArray(o) && o[0] === o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i !== caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(signedness && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   var
    caml_lxm_daba =
      caml_int64_of_string(caml_string_of_jsstring("0xdaba0b6eb09322e3")),
    caml_lxm_M =
      caml_int64_of_string(caml_string_of_jsstring("0xd1342543de82ef95"));
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_lxm_M,
     daba = caml_lxm_daba,
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_array_make(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   function caml_make_vect(len, init){return caml_array_make(len, init);}
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xd76aa478);
         d = ff(d, a, b, c, buffer[1], 12, 0xe8c7b756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070db);
         b = ff(b, c, d, a, buffer[3], 22, 0xc1bdceee);
         a = ff(a, b, c, d, buffer[4], 7, 0xf57c0faf);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787c62a);
         c = ff(c, d, a, b, buffer[6], 17, 0xa8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xfd469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098d8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8b44f7af);
         c = ff(c, d, a, b, buffer[10], 17, 0xffff5bb1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895cd7be);
         a = ff(a, b, c, d, buffer[12], 7, 0x6b901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xfd987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xa679438e);
         b = ff(b, c, d, a, buffer[15], 22, 0x49b40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xf61e2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xc040b340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265e5a51);
         b = gg(b, c, d, a, buffer[0], 20, 0xe9b6c7aa);
         a = gg(a, b, c, d, buffer[5], 5, 0xd62f105d);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xd8a1e681);
         b = gg(b, c, d, a, buffer[4], 20, 0xe7d3fbc8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21e1cde6);
         d = gg(d, a, b, c, buffer[14], 9, 0xc33707d6);
         c = gg(c, d, a, b, buffer[3], 14, 0xf4d50d87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455a14ed);
         a = gg(a, b, c, d, buffer[13], 5, 0xa9e3e905);
         d = gg(d, a, b, c, buffer[2], 9, 0xfcefa3f8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676f02d9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8d2a4c8a);
         a = hh(a, b, c, d, buffer[5], 4, 0xfffa3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771f681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6d9d6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xfde5380c);
         a = hh(a, b, c, d, buffer[1], 4, 0xa4beea44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4bdecfa9);
         c = hh(c, d, a, b, buffer[7], 16, 0xf6bb4b60);
         b = hh(b, c, d, a, buffer[10], 23, 0xbebfbc70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289b7ec6);
         d = hh(d, a, b, c, buffer[0], 11, 0xeaa127fa);
         c = hh(c, d, a, b, buffer[3], 16, 0xd4ef3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881d05);
         a = hh(a, b, c, d, buffer[9], 4, 0xd9d4d039);
         d = hh(d, a, b, c, buffer[12], 11, 0xe6db99e5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1fa27cf8);
         b = hh(b, c, d, a, buffer[2], 23, 0xc4ac5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xf4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432aff97);
         c = ii(c, d, a, b, buffer[14], 15, 0xab9423a7);
         b = ii(b, c, d, a, buffer[5], 21, 0xfc93a039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655b59c3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8f0ccc92);
         c = ii(c, d, a, b, buffer[10], 15, 0xffeff47d);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845dd1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6fa87e4f);
         d = ii(d, a, b, c, buffer[15], 10, 0xfe2ce6e0);
         c = ii(c, d, a, b, buffer[6], 15, 0xa3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4e0811a1);
         a = ii(a, b, c, d, buffer[4], 6, 0xf7537e82);
         d = ii(d, a, b, c, buffer[11], 10, 0xbd3af235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2ad7d2bb);
         b = ii(b, c, d, a, buffer[9], 21, 0xeb86d391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1fffffff;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xff;
    return t;
   }
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   var caml_ml_channels = new Array();
   function caml_ml_channel_get(id){return caml_ml_channels[id];}
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length();
   }
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr === 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length === 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max === chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] !== 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("node:fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   var caml_sys_fds = new Array(3);
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd === 1 && typeof console.log === "function")
     this.log = console.log;
    else if(fd === 2 && typeof console.error === "function")
     this.log = console.error;
    else if(typeof console.log === "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] === 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   function caml_sys_open_internal(file, idx){
    if(idx === undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_mod(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x % y;
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) !== 0);
   }
   function caml_obj_tag(x){
    if(Array.isArray(x) && x[0] === x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x === "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   var jsoo_toplevel_reloc = undefined;
   function caml_build_symbols(symb){
    var r = {}, max = - 1;
    if(symb)
     for(var i = 1; i < symb.length; i++){
      var idx = symb[i][2];
      max = Math.max(max, idx);
      r[caml_jsstring_of_string(symb[i][1])] = idx;
     }
    r.next_idx = max + 1;
    return r;
   }
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(jsoo_toplevel_reloc)
      n = caml_callback(jsoo_toplevel_reloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else{
       var n = caml_global_data.symidx.next_idx++;
       caml_global_data.symidx[name] = n;
      }
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_sys_const_max_wosize(){return 0x7fffffff / 4 | 0;}
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform === "win32"
       ? "Win32"
       : "Unix";
   function caml_sys_const_ostype_win32(){return os_type === "Win32" ? 1 : 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       (),
    caml_executable_name = caml_argv[1];
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_wrap_exception(e){
    {
     if(Array.isArray(e)) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] === 0){
     r += exn[1][1];
     if
      (exn.length === 3 && exn[2][0] === 0
       && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v === "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v === "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] === 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(Array.isArray(err) && (err[0] === 0 || err[0] === 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   var
    cst = "",
    cst$4 = "\n",
    cst$7 = " ",
    cst$11 = " ) ",
    cst_expected_a_Non_Empty_Quote = " expected a Non-Empty Quote Argument",
    cst_expected_another_Argument_ =
      " expected another Argument, but none are on the Stack",
    cst_expected_either_Ints_or_St = " expected either Ints or Strings",
    cst$18 = '"',
    cst$17 = '" ',
    cst$23 = "%",
    cst_Li = "%Li",
    cst_d = "%d",
    cst_i = "%i",
    cst_li = "%li",
    cst_ni = "%ni",
    cst_u = "%u",
    cst$10 = "( ",
    cst$24 = "*",
    cst$25 = "**",
    cst$26 = "+",
    cst_quote$0 = "+quote",
    cst$21 = ",",
    cst_characters = ", characters ",
    cst$22 = "-",
    cst$3 = ".",
    cst_fthish = ".fthish",
    cst$5 = "/",
    cst$6 = ":",
    cst$2 = ": ",
    cst$13 = ";\n",
    cst$12 = "; ",
    cst$16 = "<",
    cst$19 = "<>",
    cst$20 = "=",
    cst$15 = ">",
    cst$14 = "? ? -> ?",
    cst$1 = "@[",
    cst$0 = "@{",
    cst_Assert_failure = "Assert_failure",
    cst_Bad_function_definition = "Bad function definition",
    cst_DUNE_DIR_LOCATIONS = "DUNE_DIR_LOCATIONS",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Expected_a_Word_or_String_ = "Expected a Word or String of a Word",
    cst_Expected_end_of_string_not = "Expected end of string, not EOF",
    cst_Failure = "Failure",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Function = "Function ",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module",
    cst$8 = "[ ",
    cst$9 = "] ",
    cst_a = "a -> !",
    cst_a_a = "a a -> ?",
    cst_a_a_a = "a a -> a",
    cst_and = "and",
    cst_bind = "bind",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_chars = "chars",
    cst_concat = "concat",
    cst_del = "del",
    cst_describe = "describe",
    cst_dup = "dup",
    cst_eval = "eval",
    cst_exit = "exit",
    cst_false = "false",
    cst_false$0 = "false ",
    cst_g = "g",
    cst_hd = "hd",
    cst_if = "if",
    cst_infile = "infile",
    cst_len = "len",
    cst_not = "not",
    cst_open = "open",
    cst_or = "or",
    cst_outfile = "outfile",
    cst_over = "over",
    cst_pop = "pop",
    cst_q_a = "q -> a",
    cst_q_q = "q -> q",
    cst_quote = "quote",
    cst_rot = "rot",
    cst_s_filename = "s/filename -> !",
    cst_shd = "shd",
    cst_stl = "stl",
    cst_swap = "swap",
    cst_take = "take",
    cst_tl = "tl",
    cst_true = "true",
    cst_true$0 = "true ",
    cst_use = "use",
    cst_useup = "useup",
    cst_web_main_ml = "web/main.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var dummy = 0;
   caml_fs_init();
   var
    Out_of_memory = [248, cst_Out_of_memory, -1],
    Sys_error = [248, cst_Sys_error, -2],
    Failure = [248, cst_Failure, -3],
    Invalid_argument = [248, cst_Invalid_argument, -4],
    End_of_file = [248, cst_End_of_file, -5],
    Division_by_zero = [248, cst_Division_by_zero, -6],
    Not_found = [248, cst_Not_found, -7],
    Match_failure = [248, cst_Match_failure, -8],
    Stack_overflow = [248, cst_Stack_overflow, -9],
    Sys_blocked_io = [248, cst_Sys_blocked_io, -10],
    Assert_failure = [248, cst_Assert_failure, -11],
    Undefined_recursive_module = [248, cst_Undefined_recursive_module, -12],
    mode = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    opt = [0, 103],
    fmt$0 =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    fmt$1 =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"],
    fmt =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, cst$2, [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    _b__ = [0, cst, 0, cst],
    current_dir_name = cst$3,
    dir_sep = cst$5,
    current_dir_name$0 = cst$3,
    dir_sep$0 = "\\",
    current_dir_name$1 = cst$3,
    dir_sep$1 = cst$5,
    all =
      caml_list_of_js_array
       ([[0, 0, "lib"],
         [0, 1, "lib_root"],
         [0, 2, "libexec"],
         [0, 3, "libexec_root"],
         [0, 4, "bin"],
         [0, 5, "sbin"],
         [0, 6, "toplevel"],
         [0, 7, "share"],
         [0, 8, "share_root"],
         [0, 9, "etc"],
         [0, 10, "doc"],
         [0, 11, "stublibs"],
         [0, 12, "man"],
         [0, 13, "misc"]]),
    dune_dir_locations_env_var = cst_DUNE_DIR_LOCATIONS,
    encoded =
      "%%DUNE_PLACEHOLDER:4096:location:lib_root:8:forthish%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
    suffix = "forthish_std",
    package$1 = "forthish",
    s$3 = "int",
    s$4 = "str",
    s$5 = "bool",
    s$6 = "quote ",
    s$7 = cst$7,
    s$8 = cst$8,
    s$9 = cst$9,
    s$10 = cst$10,
    s$11 = cst$11,
    s$12 = cst$12,
    s$13 = cst$12,
    s$14 = cst,
    s$15 = cst$10,
    s$16 = " )",
    s$17 = cst$7,
    s$18 = cst$8,
    s$19 = cst$9,
    s$20 = cst$10,
    s$21 = cst$11,
    s$22 = cst$13,
    s$23 = cst$13,
    s$24 = cst$7,
    s$25 = cst$10,
    s$26 = " )\n",
    std_lib =
      '\n: id ; ( -> )\n\n: quote+ quote + ;\n\n: succ 1 + ;\n\n: pred 1 - ;\n\n: rott rot rot ; ( a b c -> c a b )\n\n: dup2 over over ; ( a b -> a b a b )\n\n: <= dup2 = rrot < or ; ( =a a -> a )\n\n: int->bool 0 > ; ( i -> ? )\n\n: bool->int [1] [0] if ; ( ? -> i )\n\n: mapq\n  : sshd \n    dup tl [] =\n    [] [ tl sshd ] if ;\n  : inn \n    dup tl [] <>\n    [ dup stl inn swap sshd quote+ ]\n    [ quote ]\n    if ;\n  inn ;\n\n: dotimes ( q i -> ! )\n  : I take ;\n  : F take open ;\n  : inn\n    I 0 >\n      [ F I 1 - : I take ; inn ]\n      [ ]\n    if ;\n  inn ;\n\n: dump [ . ] len 1 - dotimes ;\n\n: .. ( i i -> qi )\n  : I take 1 - ;\n  [] +quote [ dup hd succ swap +quote ] I dotimes ;\n\n: repeat ( a i -> qa )\n  : I take ;\n  : A take ;\n  [] [ A swap +quote ] I dotimes ;\n\n: interleave (qa b -> q[a b a..])\n  : V take ;\n  : inn \n    dup [] <>\n    [ dup hd : H take ; tl inn H quote+ V + ]\n    [ ]\n    if ;\n  inn ;\n\n: fold ( qa qb :qb a -> qb; -> qb )\n  : F take open ;\n  : inn\n    swap dup [] <>\n      [ swap over shd F swap stl swap inn ]\n      [ pop ]\n    if ;\n  inn ;\n\n: reduce ( qa :qa a -> qa; -> qa )\n  : F take open ;\n  : inn\n    swap dup [] <>\n      [ swap over shd F swap stl swap inn ]\n      [ pop ]\n    if ;\n  dup shd swap stl swap inn ;\n\n: rfold ( qa qb :qb a -> qb; -> qb )\n  : F take open ;\n  : inn\n    swap dup [] <>\n      [ swap over hd F swap tl swap inn ]\n      [ pop ]\n    if ;\n  inn ;\n\n: rreduce ( qa :qa a -> qa; -> qa )\n  : F take open ;\n  : inn\n    swap dup [] <>\n      [ swap over hd F swap tl swap inn ]\n      [ pop ]\n    if ;\n  dup hd swap tl swap inn ;\n\n: mem ( qa a -> ? )\n  [ = [ pop true ] [] if ] +quote false swap rfold ;\n\n: any ( qa :a -> ?; -> ?)\n  [ [ pop true ] [] if ] + false swap rfold ;\n\n: all ( qa :a -> ?; -> ?)\n  [ [] [ pop false ] if ] + true swap rfold ;\n\n: filter (qa :a -> ?; -> qa)\n  [ dup ] swap + [ [ swap +quote ] [ pop ] if ] + [] swap fold ;\n\n: rfilter (qa :a -> ?; -> qa)\n  [ dup ] swap + [ [ swap +quote ] [ pop ] if ] + [] swap rfold ;\n\n: count (q -> i)\n  0 [ pop 1 + ] rfold ;\n\n: rev ( qa -> qa )\n  [] [ swap +quote ] rfold ;\n\n: map ( qa :a -> b; -> qb )\n  [ swap +quote ] + [] swap fold ;\n\n: rmap ( qa :a -> b; -> qb )\n  [ swap +quote ] + [] swap rfold ;\n\n: iter ( qa :a -> u; -> u )\n  [] swap fold ;\n\n: sum ( qi -> i )\n  [ + ] rreduce ;\n\n: prod ( qi -> i )\n  [ * ] rreduce ;\n\n: max ( =qa -> a )\n  [ dup2 > [ pop ] [ swap pop ] if ] rreduce ;\n\n: min ( =qa -> a )\n  [ dup2 < [ pop ] [ swap pop ] if ] rreduce ;\n\n: enum!\n  mapq [ [ bind ] +quote ] rmap [ open ] interleave ;\n\n: match ( [ a [?] ] -> a )\n  [ ] [ open open [ swap +quote ] [ pop [] + ] if ] fold ;\n\n: matchw ( a [ b :a -> ?; ] -> b )\n  swap : A take ; [ ] [ open A swap open [ swap +quote ] [ pop [] + ] if ] fold ;\n\n: digits (i -> q)\n  : TL [] ;\n  : inn\n    dup 0 >\n      [ dup 10 % TL +quote : TL take ; 10 / inn ]\n      [ pop TL ]\n    if ;\n  dup 10 % TL +quote : TL take ; 10 / inn ;\n\n: int->str (i -> s)\n  digits\n  [[ ["0" [0 = ]]\n     ["1" [1 = ]]\n     ["2" [2 = ]]\n     ["3" [3 = ]]\n     ["4" [4 = ]]\n     ["5" [5 = ]]\n     ["6" [6 = ]]\n     ["7" [7 = ]]\n     ["8" [8 = ]]\n     ["9" [9 = ]]\n   ] matchw open\n  ] map concat ;\n\n: str->int (s -> i)\n  chars\n  [[ [0 ["0" = ]]\n     [1 ["1" = ]]\n     [2 ["2" = ]]\n     [3 ["3" = ]]\n     [4 ["4" = ]]\n     [5 ["5" = ]]\n     [6 ["6" = ]]\n     [7 ["7" = ]]\n     [8 ["8" = ]]\n     [9 ["9" = ]]\n   ] matchw open\n  ] rmap 0 [ 10 * swap 10 * + ] fold 10 / ;';
   caml_register_global
    (11, Undefined_recursive_module, cst_Undefined_recursive_module);
   caml_register_global(10, Assert_failure, cst_Assert_failure);
   caml_register_global(9, Sys_blocked_io, cst_Sys_blocked_io);
   caml_register_global(8, Stack_overflow, cst_Stack_overflow);
   caml_register_global(7, Match_failure, cst_Match_failure);
   caml_register_global(6, Not_found, cst_Not_found);
   caml_register_global(5, Division_by_zero, cst_Division_by_zero);
   caml_register_global(4, End_of_file, cst_End_of_file);
   caml_register_global(3, Invalid_argument, cst_Invalid_argument);
   caml_register_global(2, Failure, cst_Failure);
   caml_register_global(1, Sys_error, cst_Sys_error);
   caml_register_global(0, Out_of_memory, cst_Out_of_memory);
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", caml_fresh_oo_id(0)];
   function abs(x){return 0 <= x ? x : - x | 0;}
   var _a_ = cst_true, _b_ = cst_false;
   function string_of_bool(b){return b ? _a_ : _b_;}
   function symbol(l1, l2){
    if(! l1) return l2;
    var _iR_ = l1[2], h1 = l1[1];
    if(! _iR_) return [0, h1, l2];
    var match = _iR_[2], h2 = _iR_[1];
    if(! match) return [0, h1, [0, h2, l2]];
    var
     tl = match[2],
     h3 = match[1],
     block = [0, h3, 24029],
     dst = block,
     offset = 1,
     l1$0 = tl;
    for(;;){
     if(l1$0){
      var _iS_ = l1$0[2], h1$0 = l1$0[1];
      if(_iS_){
       var match$0 = _iS_[2], h2$0 = _iS_[1];
       if(match$0){
        var tl$0 = match$0[2], h3$0 = match$0[1], dst$0 = [0, h3$0, 24029];
        dst[1 + offset] = [0, h1$0, [0, h2$0, dst$0]];
        dst = dst$0;
        offset = 1;
        l1$0 = tl$0;
        continue;
       }
       dst[1 + offset] = [0, h1$0, [0, h2$0, l2]];
      }
      else
       dst[1 + offset] = [0, h1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, h1, [0, h2, block]];
    }
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = "output_substring",
    _d_ = [0, 0, [0, 7, 0]],
    _e_ = "input";
   function flush_all(param){
    var param$0 = caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_iQ_){
      var _iP_ = caml_wrap_exception(_iQ_);
      if(_iP_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_iP_, 0);
     }
     param$0 = l;
    }
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(_c_);
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_text(name){return open_in_gen(_d_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(_e_);
   }
   function print_int(i){return output_string(stdout, "" + i);}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   var
    exit_function = [0, flush_all],
    do_domain_local_at_exit = [0, function(param){}];
   function do_at_exit(param){
    caml_call1(do_domain_local_at_exit[1], 0);
    return caml_call1(caml_atomic_load(exit_function), 0);
   }
   caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    executable_name = caml_sys_executable_name(0),
    os_type$0 = caml_sys_get_config(0)[1],
    win32 = caml_sys_const_ostype_win32(0),
    max_array_length = caml_sys_const_max_wosize(0),
    max_string_length = (4 * max_array_length | 0) - 1 | 0,
    Undefined = [248, "CamlinternalLazy.Undefined", caml_fresh_oo_id(0)];
   function force_lazy_block(blk){
    if(0 !== caml_lazy_update_to_forcing(blk))
     throw caml_maybe_attach_backtrace(Undefined, 1);
    var closure = blk[1];
    blk[1] = 0;
    try{
     var result = caml_call1(closure, 0);
     blk[1] = result;
     caml_lazy_update_to_forward(blk);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     caml_lazy_reset_to_lazy(blk);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   var _h_ = "Seq.take", _i_ = "Seq.drop";
   function empty(param){return 0;}
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_iO_){return map(f, next, _iO_);}];
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){if(n < 0) invalid_arg(_h_); return take_aux(n, xs);}
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : invalid_arg(_i_);
   }
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   var _p_ = cst_hd;
   function hd(param){
    if(! param) return failwith(_p_);
    var a = param[1];
    return a;
   }
   function rev(l1$1){
    var l1 = l1$1, l2 = 0;
    for(;;){
     if(! l1) return l2;
     var l1$0 = l1[2], a = l1[1], l2$0 = [0, a, l2];
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function map$0(f, param){
    if(! param) return 0;
    var match = param[2], a1 = param[1];
    if(! match){var r1$0 = caml_call1(f, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call1(f, a1),
     r2 = caml_call1(f, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     param$0 = l;
    for(;;){
     if(param$0){
      var match$0 = param$0[2], a1$0 = param$0[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call1(f, a1$0),
        r2$0 = caml_call1(f, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       dst = dst$0;
       offset = 1;
       param$0 = l$0;
       continue;
      }
      var r1$2 = caml_call1(f, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function compare$0(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_iN_){return aux(tail, _iN_);}];
    }
    return function(_iM_){return aux(l, _iM_);};
   }
   function min(x, y){return x <= y ? x : y;}
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   var
    empty$0 = caml_create_bytes(0),
    _r_ = "String.sub / Bytes.sub",
    _s_ = "Bytes.blit",
    _t_ = "String.blit / Bytes.blit_string";
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return invalid_arg(_r_);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2){caml_blit_bytes(s1, ofs1, s2, ofs2, len); return;}
    return invalid_arg(_s_);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2){caml_blit_string(s1, ofs1, s2, ofs2, len); return;}
    return invalid_arg(_t_);
   }
   function is_space(param){
    var _iL_ = param - 9 | 0;
    a:
    {
     if(4 < _iL_ >>> 0){if(23 !== _iL_) break a;} else if(2 === _iL_) break a;
     return 1;
    }
    return 0;
   }
   function map$1(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _iJ_ = l - 1 | 0, _iI_ = 0;
    if(_iJ_ >= 0){
     var i = _iI_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _iK_ = i + 1 | 0;
      if(_iJ_ === i) break;
      i = _iK_;
     }
    }
    return r;
   }
   var
    _u_ = "Bytes.of_seq: cannot grow bytes",
    _v_ = "String.concat",
    _w_ = cst,
    _x_ = "String.index_from / Bytes.index_from",
    _y_ = "String.contains_from / Bytes.contains_from";
   function make$0(n, c){return caml_string_of_bytes(make(n, c));}
   function sub$0(s, ofs, len){
    return caml_string_of_bytes(sub(caml_bytes_of_string(s), ofs, len));
   }
   function concat(sep, l){
    if(! l) return _w_;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : invalid_arg(_v_);
       acc = acc$0;
       param = tl;
      }
      var _iH_ = acc;
      break a;
     }
     var _iH_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_iH_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_string_of_bytes(dst);
    }
   }
   function is_space$0(param){
    var _iG_ = param - 9 | 0;
    a:
    {
     if(4 < _iG_ >>> 0){if(23 !== _iG_) break a;} else if(2 === _iG_) break a;
     return 1;
    }
    return 0;
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Not_found, 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return invalid_arg(_x_);
   }
   function contains(s, c){
    var l = caml_ml_string_length(s), i = 0;
    if(l < 0) return invalid_arg(_y_);
    try{index_rec(s, l, i, c); var _iE_ = 1; return _iE_;}
    catch(_iF_){
     var _iD_ = caml_wrap_exception(_iF_);
     if(_iD_ === Not_found) return 0;
     throw caml_maybe_attach_backtrace(_iD_, 0);
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _iC_ = 0 <= diff ? 1 : 0;
    if(! _iC_) return _iC_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _iy_ = caml_ml_string_length(s) - 1 | 0;
    if(_iy_ >= 0){
     var i = _iy_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _iA_ = r[1];
       r[1] = [0, sub$0(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _iA_];
       j[1] = i;
      }
      var _iB_ = i - 1 | 0;
      if(0 === i) break;
      i = _iB_;
     }
    }
    var _iz_ = r[1];
    return [0, sub$0(s, 0, j[1]), _iz_];
   }
   function to_seq$0(s){
    var s$0 = caml_bytes_of_string(s);
    function aux(i, param){
     if(i === caml_ml_bytes_length(s$0)) return 0;
     var x = caml_bytes_get(s$0, i), _iw_ = i + 1 | 0;
     return [0, x, function(_ix_){return aux(_iw_, _ix_);}];
    }
    var _iu_ = 0;
    return function(_iv_){return aux(_iu_, _iv_);};
   }
   function of_seq(seq$0){
    var n = [0, 0], buf = [0, make(256, 0)], seq = seq$0;
    for(;;){
     var match = caml_call1(seq, 0);
     if(! match) return caml_string_of_bytes(sub(buf[1], 0, n[1]));
     var next = match[2], x = match[1];
     if(n[1] === caml_ml_bytes_length(buf[1])){
      var
       new_len = min(2 * caml_ml_bytes_length(buf[1]) | 0, max_string_length);
      if(caml_ml_bytes_length(buf[1]) === new_len) failwith(_u_);
      var new_buf = make(new_len, 0);
      blit(buf[1], 0, new_buf, 0, n[1]);
      buf[1] = new_buf;
     }
     caml_bytes_set(buf[1], n[1], x);
     n[1]++;
     seq = next;
    }
   }
   function get_int64_le(s, i){
    var b = caml_bytes_of_string(s);
    return caml_bytes_get64(b, i);
   }
   var Empty = [248, "Stdlib.Stack.Empty", caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0;}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   var Empty$0 = [248, "Stdlib.Queue.Empty", caml_fresh_oo_id(0)];
   function clear$0(q){q[1] = 0; q[2] = 0; q[3] = 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    if(match){q[1] = q[1] + 1 | 0; match[2] = cell; q[3] = cell; return;}
    q[1] = 1;
    q[2] = cell;
    q[3] = cell;
   }
   var
    _A_ = "Buffer.add: cannot grow buffer",
    _B_ = "Buffer.add_substring/add_subbytes";
   function create$0(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = max_string_length < n$0 ? max_string_length : n$0,
     s = caml_create_bytes(n$1);
    return [0, [0, s, n$1], 0, s];
   }
   function contents(b){return sub_string(b[1][1], 0, b[2]);}
   function resize(b, more){
    var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(max_string_length < new_len[1])
     if((old_pos + more | 0) <= max_string_length)
      new_len[1] = max_string_length;
     else
      failwith(_A_);
    var new_buffer = caml_create_bytes(new_len[1]);
    blit(b[1][1], 0, new_buffer, 0, b[2]);
    b[1] = [0, new_buffer, new_len[1]];
   }
   function add_char(b, c){
    var pos = b[2], match = b[1], length = match[2], buffer = match[1];
    if(length <= pos){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], c);
    }
    else
     caml_bytes_unsafe_set(buffer, pos, c);
    b[2] = pos + 1 | 0;
   }
   function add_substring(b, s, offset, len){
    var _ir_ = offset < 0 ? 1 : 0;
    if(_ir_)
     var _is_ = _ir_;
    else
     var
      _it_ = len < 0 ? 1 : 0,
      _is_ = _it_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_is_) invalid_arg(_B_);
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     blit_string(s, offset, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, offset, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_string(b, s){
    var
     len = caml_ml_string_length(s),
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     blit_string(s, 0, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, 0, buffer, position, len);
    b[2] = new_position;
   }
   var none = [0, 0], st = caml_make_vect(8, none);
   caml_domain_dls_set(st);
   var
    key_counter = [0, 0],
    parent_keys = [0, 0],
    _z_ = "Array.blit",
    _C_ = [0, "domain.ml", 184, 13];
   function new_key(split_from_parent, init_orphan){
    var
     idx = caml_atomic_fetch_add(key_counter, 1),
     k = [0, idx, init_orphan];
    if(split_from_parent){
     var split = split_from_parent[1], ki = [0, k, split];
     for(;;){
      var l = caml_atomic_load(parent_keys);
      if(! (1 - caml_atomic_cas(parent_keys, l, [0, ki, l]))) break;
     }
    }
    return k;
   }
   function maybe_grow(idx){
    for(;;){
     var st = caml_domain_dls_get(0), len = st.length - 1;
     if(idx < len) return st;
     var new_sz = len;
     for(;;){if(idx < new_sz) break; var s = 2 * new_sz | 0; new_sz = s;}
     var new_st = caml_make_vect(new_sz, none);
     a:
     {
      if
       (0 <= len
        &&
         (st.length - 1 - len | 0) >= 0 && (new_st.length - 1 - len | 0) >= 0){caml_array_blit(st, 0, new_st, 0, len); break a;}
      invalid_arg(_z_);
     }
     if(caml_domain_dls_compare_and_set(st, new_st)) return new_st;
    }
   }
   function set(param, x){
    var idx = param[1], st = maybe_grow(idx);
    caml_check_bound(st, idx)[1 + idx] = x;
   }
   function get(param){
    var
     init = param[2],
     idx = param[1],
     st = maybe_grow(idx),
     oldval = caml_check_bound(st, idx)[1 + idx];
    if(oldval !== none) return oldval;
    var
     new_obj = caml_call1(init, 0),
     st$0 = caml_domain_dls_get(0),
     curval = caml_check_bound(st$0, idx)[1 + idx],
     _iq_ = curval === oldval ? (st$0[1 + idx] = new_obj, 1) : 0;
    if(_iq_) return new_obj;
    var updated_obj = caml_check_bound(st$0, idx)[1 + idx];
    if(updated_obj !== none) return updated_obj;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
   }
   var
    first_domain_spawned = [0, 0],
    at_exit_key =
      new_key(0, function(param){return function(param){return 0;};});
   function at_exit(f){
    var old_exit = get(at_exit_key);
    function new_exit(param){
     caml_call1(f, 0);
     return caml_call1(old_exit, 0);
    }
    return set(at_exit_key, new_exit);
   }
   function do_at_exit$0(param){
    var f = get(at_exit_key);
    return caml_call1(f, 0);
   }
   do_domain_local_at_exit[1] = do_at_exit$0;
   var
    _E_ = "@]",
    _F_ = "@}",
    _G_ = "@?",
    _H_ = "@\n",
    _I_ = "@.",
    _J_ = "@@",
    _K_ = "@%",
    _L_ = "%c",
    _M_ = "%s",
    _N_ = cst_i,
    _O_ = cst_li,
    _P_ = cst_ni,
    _Q_ = cst_Li,
    _R_ = "%f",
    _S_ = "%B",
    _U_ = "%{",
    _V_ = "%}",
    _W_ = "%(",
    _X_ = "%)",
    _Y_ = "%a",
    _Z_ = "%t",
    ___ = "%?",
    _$_ = "%r",
    _aa_ = "%_r",
    _ab_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _ac_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _ad_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _ae_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _af_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _ag_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _ah_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _ai_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _aj_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _ak_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _al_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _am_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _an_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _ao_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _ap_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _aq_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var len = caml_ml_bytes_length(buf[2]), min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      x = len * 2 | 0,
      new_len = min_len <= x ? x : min_len,
      new_str = caml_create_bytes(new_len);
     blit(buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    blit_string(s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
   }
   function buffer_contents(buf){return sub_string(buf[2], 0, buf[1]);}
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return _E_;
       case 1:
        return _F_;
       case 2:
        return _G_;
       case 3:
        return _H_;
       case 4:
        return _I_;
       case 5:
        return _J_;
       default: return _K_;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default: var c = formatting_lit[1], s2 = make$0(1, c); return "@" + s2;
    }
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, _L_);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, _M_);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, _N_);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, _O_);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, _P_);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, _Q_);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, _R_);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, _S_);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, _U_);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, _V_);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, _W_);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, _X_);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, _Y_);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, _Z_);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, ___);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, _$_);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, _aa_);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0, , function(param){}, , function(param){}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        af = match[2];
       return [0, , function(param){af(0);}, , de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        af$0 = match$0[2];
       return [0, , function(param){af$0(0);}, , de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        af$1 = match$1[2];
       return [0, , function(param){af$1(0);}, , de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        af$2 = match$2[2];
       return [0, , function(param){af$2(0);}, , de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        af$3 = match$3[2];
       return [0, , function(param){af$3(0);}, , de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        af$4 = match$4[2];
       return [0, , function(param){af$4(0);}, , de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        af$5 = match$5[2];
       return [0, , function(param){af$5(0);}, , de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        af$6 = match$6[2];
       return [0, , function(param){af$6(0);}, , de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        af$7 = match$7[2];
       return [0, , function(param){af$7(0);}, , de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        af$8 = match$8[2],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        ga = match$9[2];
       return [0,
               ,
               function(param){ga(0); af$8(0);},
               ,
               function(param){jd(0); de$8(0);}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        af$9 = match$10[2];
       return [0, , function(param){af$9(0);}, , de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        af$10 = match$11[2];
       return [0, , function(param){af$10(0);}, , de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        af$11 = match$12[2];
       return [0, , function(param){af$11(0);}, , de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        af$12 = match$13[2];
       return [0, , function(param){af$12(0);}, , function(param){de$12(0);}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        af$13 = match$14[2];
       return [0, , function(param){af$13(0);}, , function(param){de$13(0);}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _ip_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _ip_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _aq_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aj_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ad_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _ai_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ah_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _af_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", caml_fresh_oo_id(0)],
    _j_ = "\\\\",
    _k_ = "\\'",
    _l_ = "\\b",
    _m_ = "\\t",
    _n_ = "\\n",
    _o_ = "\\r",
    _ar_ = cst_d,
    _as_ = "%+d",
    _at_ = "% d",
    _au_ = cst_i,
    _av_ = "%+i",
    _aw_ = "% i",
    _ax_ = "%x",
    _ay_ = "%#x",
    _az_ = "%X",
    _aA_ = "%#X",
    _aB_ = "%o",
    _aC_ = "%#o",
    _aD_ = cst_u,
    _aE_ = "%Ld",
    _aF_ = "%+Ld",
    _aG_ = "% Ld",
    _aH_ = cst_Li,
    _aI_ = "%+Li",
    _aJ_ = "% Li",
    _aK_ = "%Lx",
    _aL_ = "%#Lx",
    _aM_ = "%LX",
    _aN_ = "%#LX",
    _aO_ = "%Lo",
    _aP_ = "%#Lo",
    _aQ_ = "%Lu",
    _aR_ = "%ld",
    _aS_ = "%+ld",
    _aT_ = "% ld",
    _aU_ = cst_li,
    _aV_ = "%+li",
    _aW_ = "% li",
    _aX_ = "%lx",
    _aY_ = "%#lx",
    _aZ_ = "%lX",
    _a0_ = "%#lX",
    _a1_ = "%lo",
    _a2_ = "%#lo",
    _a3_ = "%lu",
    _a4_ = "%nd",
    _a5_ = "%+nd",
    _a6_ = "% nd",
    _a7_ = cst_ni,
    _a8_ = "%+ni",
    _a9_ = "% ni",
    _a__ = "%nx",
    _a$_ = "%#nx",
    _ba_ = "%nX",
    _bb_ = "%#nX",
    _bc_ = "%no",
    _bd_ = "%#no",
    _be_ = "%nu",
    _bf_ = "neg_infinity",
    _bg_ = "infinity",
    _bh_ = "nan",
    _bi_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    _bj_ = "Printf: bad conversion %[",
    _bk_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _bl_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _bm_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    _bn_ = "Printf: bad conversion %_",
    _bo_ = cst$0,
    _bp_ = cst$1,
    _bq_ = cst$0,
    _br_ = cst$1;
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _in_ = [0, erase_rel(sub_fmtty1)];
        if(caml_notequal([0, erase_rel(sub_fmtty$1)], _in_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 = type_format_gen(fmt_rest$13, erase_rel(fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _io_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _io_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _io_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _il_ = [0, erase_rel(sub1_fmtty)];
        if(caml_notequal([0, erase_rel(sub1_fmtty$0)], _il_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _im_ = [0, erase_rel(sub2_fmtty$1)];
        if(caml_notequal([0, erase_rel(sub2_fmtty$2)], _im_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (erase_rel(sub_fmtty_rest$17), fmt, fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = abs(width);
    if(width$0 <= len) return str;
    var _ik_ = 2 === padty$0 ? 48 : 32, res = make(width$0, _ik_);
    switch(padty$0){
      case 0:
       blit_string(str, 0, res, 0, len); break;
      case 1:
       blit_string(str, 0, res, width$0 - len | 0, len); break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        blit_string(str, 1, res, (width$0 - len | 0) + 1 | 0, len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        blit_string(str, 2, res, (width$0 - len | 0) + 2 | 0, len - 2 | 0);
        break;
       }
       blit_string(str, 0, res, width$0 - len | 0, len);
    }
    return caml_string_of_bytes(res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = abs(prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = make(prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            blit_string
             (str, 2, res$1, (prec$0 - len | 0) + 4 | 0, len - 2 | 0);
            return caml_string_of_bytes(res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = make(prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       blit_string(str, 1, res$0, (prec$0 - len | 0) + 2 | 0, len - 1 | 0);
       return caml_string_of_bytes(res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = make(prec$0, 48);
      blit_string(str, 0, res, prec$0 - len | 0, len);
      return caml_string_of_bytes(res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     s$0 = caml_bytes_of_string(str),
     n = [0, 0],
     _ic_ = caml_ml_bytes_length(s$0) - 1 | 0,
     _ib_ = 0;
    if(_ic_ >= 0){
     var i$0 = _ib_;
     for(;;){
      var match = caml_bytes_unsafe_get(s$0, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ig_ = match - 34 | 0;
          if(58 < _ig_ >>> 0){
           if(93 <= _ig_) break c;
          }
          else if(56 < _ig_ - 1 >>> 0) break b;
          var _ih_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ih_ = 4;
        break a;
       }
       var _ih_ = 2;
      }
      n[1] = n[1] + _ih_ | 0;
      var _ii_ = i$0 + 1 | 0;
      if(_ic_ === i$0) break;
      i$0 = _ii_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s$0))
     var _ij_ = s$0;
    else{
     var s = caml_create_bytes(n[1]);
     n[1] = 0;
     var _ie_ = caml_ml_bytes_length(s$0) - 1 | 0, _id_ = 0;
     if(_ie_ >= 0){
      var i = _id_;
      for(;;){
       var c = caml_bytes_unsafe_get(s$0, i);
       a:
       {
        b:
        {
         c:
         {
          if(35 <= c){
           if(92 !== c){if(127 <= c) break c; break b;}
          }
          else{
           if(32 > c){
            if(14 <= c) break c;
            switch(c){
              case 8:
               caml_bytes_unsafe_set(s, n[1], 92);
               n[1]++;
               caml_bytes_unsafe_set(s, n[1], 98);
               break a;
              case 9:
               caml_bytes_unsafe_set(s, n[1], 92);
               n[1]++;
               caml_bytes_unsafe_set(s, n[1], 116);
               break a;
              case 10:
               caml_bytes_unsafe_set(s, n[1], 92);
               n[1]++;
               caml_bytes_unsafe_set(s, n[1], 110);
               break a;
              case 13:
               caml_bytes_unsafe_set(s, n[1], 92);
               n[1]++;
               caml_bytes_unsafe_set(s, n[1], 114);
               break a;
              default: break c;
            }
           }
           if(34 > c) break b;
          }
          caml_bytes_unsafe_set(s, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s, n[1], c);
          break a;
         }
         caml_bytes_unsafe_set(s, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s, n[1], 48 + (c / 100 | 0) | 0);
         n[1]++;
         caml_bytes_unsafe_set(s, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
         n[1]++;
         caml_bytes_unsafe_set(s, n[1], 48 + (c % 10 | 0) | 0);
         break a;
        }
        caml_bytes_unsafe_set(s, n[1], c);
       }
       n[1]++;
       var _if_ = i + 1 | 0;
       if(_ie_ === i) break;
       i = _if_;
      }
     }
     var _ij_ = s;
    }
    var
     str$0 = caml_string_of_bytes(_ij_),
     l = caml_ml_string_length(str$0),
     res = make(l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_string_of_bytes(res);
   }
   function format_of_fconv(fconv, prec){
    var prec$0 = abs(prec), cF = opt[1];
    switch(fconv[2]){
      case 0:
       var symb = 102; break;
      case 1:
       var symb = 101; break;
      case 2:
       var symb = 69; break;
      case 3:
       var symb = 103; break;
      case 4:
       var symb = 71; break;
      case 5:
       var symb = cF; break;
      case 6:
       var symb = 104; break;
      case 7:
       var symb = 72; break;
      default: var symb = 70;
    }
    var buf = buffer_create(16);
    buffer_add_char(buf, 37);
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) buffer_add_char(buf, 35);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, "" + prec$0);
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _h8_ = caml_ml_string_length(s) - 1 | 0, _h7_ = 0;
    if(_h8_ >= 0){
     var i$0 = _h7_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ia_ = i$0 + 1 | 0;
      if(_h8_ === i$0) break;
      i$0 = _ia_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _h__ = caml_ml_string_length(s) - 1 | 0,
     _h9_ = 0;
    if(_h__ >= 0){
     var i = _h9_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _h$_ = i + 1 | 0;
      if(_h__ === i) break;
      i = _h$_;
     }
    }
    return caml_string_of_bytes(buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _h6_ = _as_; break;
      case 2:
       var _h6_ = _at_; break;
      case 4:
       var _h6_ = _av_; break;
      case 5:
       var _h6_ = _aw_; break;
      case 6:
       var _h6_ = _ax_; break;
      case 7:
       var _h6_ = _ay_; break;
      case 8:
       var _h6_ = _az_; break;
      case 9:
       var _h6_ = _aA_; break;
      case 10:
       var _h6_ = _aB_; break;
      case 11:
       var _h6_ = _aC_; break;
      case 0:
      case 13:
       var _h6_ = _ar_; break;
      case 3:
      case 14:
       var _h6_ = _au_; break;
      default: var _h6_ = _aD_;
    }
    return transform_int_alt(iconv, caml_format_int(_h6_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _h5_ = _aS_; break;
      case 2:
       var _h5_ = _aT_; break;
      case 4:
       var _h5_ = _aV_; break;
      case 5:
       var _h5_ = _aW_; break;
      case 6:
       var _h5_ = _aX_; break;
      case 7:
       var _h5_ = _aY_; break;
      case 8:
       var _h5_ = _aZ_; break;
      case 9:
       var _h5_ = _a0_; break;
      case 10:
       var _h5_ = _a1_; break;
      case 11:
       var _h5_ = _a2_; break;
      case 0:
      case 13:
       var _h5_ = _aR_; break;
      case 3:
      case 14:
       var _h5_ = _aU_; break;
      default: var _h5_ = _a3_;
    }
    return transform_int_alt(iconv, caml_format_int(_h5_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _h4_ = _a5_; break;
      case 2:
       var _h4_ = _a6_; break;
      case 4:
       var _h4_ = _a8_; break;
      case 5:
       var _h4_ = _a9_; break;
      case 6:
       var _h4_ = _a__; break;
      case 7:
       var _h4_ = _a$_; break;
      case 8:
       var _h4_ = _ba_; break;
      case 9:
       var _h4_ = _bb_; break;
      case 10:
       var _h4_ = _bc_; break;
      case 11:
       var _h4_ = _bd_; break;
      case 0:
      case 13:
       var _h4_ = _a4_; break;
      case 3:
      case 14:
       var _h4_ = _a7_; break;
      default: var _h4_ = _be_;
    }
    return transform_int_alt(iconv, caml_format_int(_h4_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _h3_ = _aF_; break;
      case 2:
       var _h3_ = _aG_; break;
      case 4:
       var _h3_ = _aI_; break;
      case 5:
       var _h3_ = _aJ_; break;
      case 6:
       var _h3_ = _aK_; break;
      case 7:
       var _h3_ = _aL_; break;
      case 8:
       var _h3_ = _aM_; break;
      case 9:
       var _h3_ = _aN_; break;
      case 10:
       var _h3_ = _aO_; break;
      case 11:
       var _h3_ = _aP_; break;
      case 0:
      case 13:
       var _h3_ = _aE_; break;
      case 3:
      case 14:
       var _h3_ = _aH_; break;
      default: var _h3_ = _aQ_;
    }
    return transform_int_alt(iconv, caml_int64_format(_h3_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = caml_classify_float(x);
     return 3 === match ? x < 0. ? _bf_ : _bg_ : 4 <= match ? _bh_ : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _h1_ = 0;
        else{
         var _h0_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _h0_ >>> 0){
           if(55 === _h0_) break a;
          }
          else if(21 < _h0_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _h1_ = 1;
        }
        var _h2_ = _h1_ ? str : str + cst$3;
        return caml_special_val(_h2_);
       }
      case 6:
       return hex(0);
      case 7:
       var s = hex(0), s$0 = caml_bytes_of_string(s);
       return caml_string_of_bytes(map$1(uppercase_ascii, s$0));
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         a:
         {
          b:
          {
           if(40 <= c){
            if(92 === c){var str = _j_; break a;}
            if(127 > c) break b;
           }
           else{
            if(32 <= c){if(39 > c) break b; var str = _k_; break a;}
            if(14 > c)
             switch(c){
               case 8:
                var str = _l_; break a;
               case 9:
                var str = _m_; break a;
               case 10:
                var str = _n_; break a;
               case 13:
                var str = _o_; break a;
             }
           }
           var s = caml_create_bytes(4);
           caml_bytes_unsafe_set(s, 0, 92);
           caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
           caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
           caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
           var str = caml_string_of_bytes(s);
           break a;
          }
          var s$0 = caml_create_bytes(1);
          caml_bytes_unsafe_set(s$0, 0, c);
          var str = caml_string_of_bytes(s$0);
         }
         var l = caml_ml_string_length(str), res = make(l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_string_of_bytes(res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, string_of_bool);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var rest$12 = fmt$0[3], sub_fmtty = fmt$0[2], buf = buffer_create(16);
        bprint_fmtty(buf, sub_fmtty);
        var ty = buffer_contents(buf);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var
          fmt$0 = param[1],
          fmtty$0 = erase_rel(symm(fmtty)),
          _hZ_ = type_format_gen(fmt$0, fmtty$0);
         if(typeof _hZ_[2] !== "number")
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         var fmt = _hZ_[1];
         return make_printf(k$0, acc$0, concat_fmt(fmt, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _hX_ = fmt$0[1];
        if(0 === _hX_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _hX_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _hX_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bi_], 1);
       case 20:
        var rest$19 = fmt$0[3], new_acc = [8, acc$0, _bj_];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            if(counter >= 50)
             return caml_trampoline_return
                     (make_invalid_arg, [0, k$0, acc$0, rest$22]);
            var counter$1 = counter + 1 | 0;
            return make_invalid_arg(counter$1, k$0, acc$0, rest$22);
           case 1:
            if(counter >= 50)
             return caml_trampoline_return
                     (make_invalid_arg, [0, k$0, acc$0, rest$22]);
            var counter$2 = counter + 1 | 0;
            return make_invalid_arg(counter$2, k$0, acc$0, rest$22);
           case 2:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bk_], 1);
           default:
            if(counter >= 50)
             return caml_trampoline_return
                     (make_invalid_arg, [0, k$0, acc$0, rest$22]);
            var counter$3 = counter + 1 | 0;
            return make_invalid_arg(counter$3, k$0, acc$0, rest$22);
         }
        switch(ign[0]){
          case 0:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$4 = counter + 1 | 0;
           return make_invalid_arg(counter$4, k$0, acc$0, rest$22);
          case 1:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$5 = counter + 1 | 0;
           return make_invalid_arg(counter$5, k$0, acc$0, rest$22);
          case 2:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$6 = counter + 1 | 0;
           return make_invalid_arg(counter$6, k$0, acc$0, rest$22);
          case 3:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$7 = counter + 1 | 0;
           return make_invalid_arg(counter$7, k$0, acc$0, rest$22);
          case 4:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$8 = counter + 1 | 0;
           return make_invalid_arg(counter$8, k$0, acc$0, rest$22);
          case 5:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$9 = counter + 1 | 0;
           return make_invalid_arg(counter$9, k$0, acc$0, rest$22);
          case 6:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$10 = counter + 1 | 0;
           return make_invalid_arg(counter$10, k$0, acc$0, rest$22);
          case 7:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$11 = counter + 1 | 0;
           return make_invalid_arg(counter$11, k$0, acc$0, rest$22);
          case 8:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$12 = counter + 1 | 0;
           return make_invalid_arg(counter$12, k$0, acc$0, rest$22);
          case 9:
           var fmtty$0 = ign[2];
           if(counter >= 50)
            return caml_trampoline_return
                    (make_from_fmtty$0, [0, k$0, acc$0, fmtty$0, rest$22]);
           var counter$15 = counter + 1 | 0;
           return make_from_fmtty$0(counter$15, k$0, acc$0, fmtty$0, rest$22);
          case 10:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$13 = counter + 1 | 0;
           return make_invalid_arg(counter$13, k$0, acc$0, rest$22);
          default:
           if(counter >= 50)
            return caml_trampoline_return
                    (make_invalid_arg, [0, k$0, acc$0, rest$22]);
           var counter$14 = counter + 1 | 0;
           return make_invalid_arg(counter$14, k$0, acc$0, rest$22);
        }
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _hY_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _hY_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _hY_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty(k, acc, concat_fmtty(ty, rest$8), fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(_hW_, param){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bl_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bm_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _hV_ = [8, acc, _bn_];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _hV_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _hV_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _hU_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _hU_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _hU_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return output_string(o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         output_string(o, _bo_);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         output_string(o, _bp_);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1]; output_acc(o, p$4); caml_ml_flush(o); return;
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return invalid_arg(msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return output_string(o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        caml_ml_output_char(o, c);
        return;
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return add_string(b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         add_string(b, _bq_);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         add_string(b, _br_);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        return add_string(b, caml_call1(f, 0));
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return invalid_arg(msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return add_string(b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return add_char(b, c);
     }
    }
   }
   function fprintf(oc, fmt$0){
    var fmt = fmt$0[1];
    return make_printf(function(acc){output_acc(oc, acc); return 0;}, 0, fmt);
   }
   function sprintf(fmt$0){
    var fmt = fmt$0[1];
    function k(acc){
     var buf = create$0(64);
     strput_acc(buf, acc);
     var s = contents(buf);
     return s;
    }
    return make_printf(k, 0, fmt);
   }
   var
    printers = [0, 0],
    _bs_ = [0, [3, 0, 0], "%S"],
    _bt_ = "_",
    _bu_ = [0, [4, 0, 0, 0, 0], cst_d],
    _bv_ = cst,
    _bw_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _bx_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _by_ = cst,
    _bz_ = cst,
    _bA_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    _bB_ = "Out of memory",
    _bC_ = "Stack overflow",
    _bD_ = "Pattern matching failed",
    _bE_ = "Assertion failed",
    _bF_ = "Undefined recursive module",
    _bG_ = "Raised at",
    _bH_ = "Re-raised at",
    _bI_ = "Raised by primitive operation at",
    _bJ_ = "Called from",
    _bK_ = [0, [12, 32, [4, 0, 0, 0, 0]], " %d"],
    _bL_ = " (inlined)",
    _bM_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2, 0, [11, ", line", [2, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line%s, characters %d-%d'],
    _bN_ = cst,
    _bO_ = [0, [11, "s ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]], "s %d-%d"],
    _bP_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _bQ_ = [0, [2, 0, [12, 10, 0]], "%s\n"];
   function field(x, i$1){
    var f = x[1 + i$1];
    if(! (1 - (typeof f === "number" ? 1 : 0)))
     return caml_call1(sprintf(_bu_), f);
    if(caml_obj_tag(f) === 252) return caml_call1(sprintf(_bs_), f);
    if(caml_obj_tag(f) !== 253) return _bt_;
    var
     s1 = caml_format_float("%.12g", f),
     l = caml_ml_string_length(s1),
     i = 0;
    for(;;){
     if(l <= i) return s1 + cst$3;
     var match = caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return _bv_;
    var _hS_ = other_fields(x, i + 1 | 0), _hT_ = field(x, i);
    return caml_call2(sprintf(_bw_), _hT_, _hS_);
   }
   function string_of_extension_constructo(t){
    if(0 === caml_obj_tag(t)){
     var constructor = t[1][1], match = t.length - 1;
     if(2 < match >>> 0)
      var
       _hO_ = other_fields(t, 2),
       _hP_ = field(t, 1),
       _hR_ = caml_call2(sprintf(_bx_), _hP_, _hO_);
     else
      switch(match){
        case 0:
         var _hR_ = _by_; break;
        case 1:
         var _hR_ = _bz_; break;
        default:
         var _hQ_ = field(t, 1), _hR_ = caml_call1(sprintf(_bA_), _hQ_);
      }
     var match$0 = [0, constructor, [0, _hR_]];
    }
    else
     var match$0 = [0, t[1], 0];
    var fields_opt = match$0[2], constructor$0 = match$0[1];
    if(! fields_opt) return constructor$0;
    var s2 = fields_opt[1];
    return constructor$0 + s2;
   }
   function to_string(e){
    a:
    {
     b:
     {
      var param = caml_atomic_load(printers);
      for(;;){
       if(! param) break;
       var tl = param[2], hd = param[1];
       c:
       {
        try{var val = caml_call1(hd, e);}catch(_hN_){break c;}
        if(val) break b;
       }
       param = tl;
      }
      var match$2 = 0;
      break a;
     }
     var s = val[1], match$2 = [0, s];
    }
    if(match$2){var s$0 = match$2[1]; return s$0;}
    if(e === Out_of_memory) return _bB_;
    if(e === Stack_overflow) return _bC_;
    if(e[1] === Match_failure){
     var match = e[2], char$0 = match[3], line = match[2], file = match[1];
     return caml_call5
             (sprintf(locfmt), file, line, char$0, char$0 + 5 | 0, _bD_);
    }
    if(e[1] === Assert_failure){
     var
      match$0 = e[2],
      char$1 = match$0[3],
      line$0 = match$0[2],
      file$0 = match$0[1];
     return caml_call5
             (sprintf(locfmt), file$0, line$0, char$1, char$1 + 6 | 0, _bE_);
    }
    if(e[1] !== Undefined_recursive_module)
     return string_of_extension_constructo(e);
    var
     match$1 = e[2],
     char$2 = match$1[3],
     line$1 = match$1[2],
     file$1 = match$1[1];
    return caml_call5
            (sprintf(locfmt), file$1, line$1, char$2, char$2 + 6 | 0, _bF_);
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var
     a = caml_convert_raw_backtrace(raw_backtrace),
     _hL_ = a.length - 2 | 0,
     _hK_ = 0;
    if(_hL_ >= 0){
     var pos = _hK_;
     for(;;){
      var slot = caml_check_bound(a, pos)[1 + pos];
      let pos$0 = pos;
      var
       info =
         function(is_raise){
          return is_raise
                  ? 0 === pos$0 ? _bG_ : _bH_
                  : 0 === pos$0 ? _bI_ : _bJ_;
         };
      if(0 === slot[0]){
       if(slot[3] === slot[6])
        var _hA_ = slot[3], lines = caml_call1(sprintf(_bK_), _hA_);
       else
        var
         _hH_ = slot[6],
         _hI_ = slot[3],
         lines = caml_call2(sprintf(_bO_), _hI_, _hH_);
       var
        _hB_ = slot[7],
        _hC_ = slot[4],
        _hD_ = slot[8] ? _bL_ : _bN_,
        _hE_ = slot[2],
        _hF_ = slot[9],
        _hG_ = info(slot[1]),
        match =
          [0,
           caml_call7
            (sprintf(_bM_), _hG_, _hF_, _hE_, _hD_, lines, _hC_, _hB_)];
      }
      else if(slot[1])
       var match = 0;
      else
       var _hJ_ = info(0), match = [0, caml_call1(sprintf(_bP_), _hJ_)];
      if(match){var str = match[1]; caml_call1(fprintf(outchan, _bQ_), str);}
      var _hM_ = pos + 1 | 0;
      if(_hL_ === pos) break;
      pos = _hM_;
     }
    }
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_atomic_load(printers),
      new_printers = [0, fn, old_printers],
      success = caml_atomic_cas(printers, old_printers, new_printers),
      _hz_ = 1 - success;
     if(! _hz_) return _hz_;
    }
   }
   var
    errors =
      [0,
        cst,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    empty_backtrace = [0],
    _bR_ = "Fatal error: out of memory in uncaught exception handler";
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use
          ? empty_backtrace
          : caml_get_exception_raw_backtrace(0);
      try{do_at_exit(0);}catch(_hy_){}
      try{
       var _ho_ = to_string(exn$0);
       caml_call1(fprintf(stderr, fmt), _ho_);
       print_raw_backtrace(stderr, raw_backtrace);
       var status = caml_ml_debug_info_status(0);
       if(status < 0){
        var _hp_ = abs(status);
        prerr_endline(caml_check_bound(errors, _hp_)[1 + _hp_]);
       }
       var _hv_ = caml_ml_flush(stderr), _ht_ = _hv_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtrace(0),
        _hr_ = to_string(exn$0);
       caml_call1(fprintf(stderr, fmt$0), _hr_);
       print_raw_backtrace(stderr, raw_backtrace);
       var _hs_ = to_string(exn);
       caml_call1(fprintf(stderr, fmt$1), _hs_);
       print_raw_backtrace(stderr, raw_backtrace$0);
       var _ht_ = caml_ml_flush(stderr);
      }
      var _hu_ = _ht_;
     }
     catch(_hx_){
      var _hq_ = caml_wrap_exception(_hx_);
      if(_hq_ !== Out_of_memory) throw caml_maybe_attach_backtrace(_hq_, 0);
      var _hu_ = prerr_endline(_bR_);
     }
     return _hu_;
    }
    catch(_hw_){return 0;}
   }
   caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Finally_raised = [248, "Stdlib.Fun.Finally_raised", caml_fresh_oo_id(0)];
   register_printer
    (function(param){
      if(param[1] !== Finally_raised) return 0;
      var exn = param[2], s2 = to_string(exn);
      return [0, "Fun.Finally_raised: " + s2];
     });
   var
    _bS_ =
      "In_channel.input_all: channel content is larger than maximum string length";
   function read_upto(ic, buf, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 !== len$0){
      var r = input(ic, buf, ofs$0, len$0);
      if(0 !== r){
       var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
       ofs$0 = ofs$1;
       len$0 = len$1;
       continue;
      }
     }
     return ofs$0 - ofs | 0;
    }
   }
   function ensure(buf, ofs, n){
    var len = caml_ml_bytes_length(buf);
    if((ofs + n | 0) <= len) return buf;
    var new_len = [0, len];
    for(;;){
     if(new_len[1] >= (ofs + n | 0)){
      var
       new_len$0 = new_len[1],
       new_len$1 =
         new_len$0 <= max_string_length
          ? new_len$0
          : ofs < max_string_length ? max_string_length : failwith(_bS_),
       new_buf = caml_create_bytes(new_len$1);
      blit(buf, 0, new_buf, 0, ofs);
      return new_buf;
     }
     new_len[1] = (2 * new_len[1] | 0) + 1 | 0;
    }
   }
   function input_all(ic){
    var chunk_size = 65536;
    try{
     var
      _hi_ = caml_ml_pos_in(ic),
      _hl_ = caml_ml_channel_size(ic) - _hi_ | 0,
      initial_size = _hl_;
    }
    catch(_hn_){
     var _hj_ = caml_wrap_exception(_hn_);
     if(_hj_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_hj_, 0);
     var initial_size = -1;
    }
    var
     initial_size$0 = 0 <= initial_size ? initial_size : chunk_size,
     initial_size$1 =
       initial_size$0 <= max_string_length
        ? initial_size$0
        : max_string_length,
     buf = caml_create_bytes(initial_size$1),
     nread = read_upto(ic, buf, 0, initial_size$1);
    if(nread < initial_size$1) return sub_string(buf, 0, nread);
    try{var c = caml_ml_input_char(ic);}
    catch(_hm_){
     var _hk_ = caml_wrap_exception(_hm_);
     if(_hk_ === End_of_file) return caml_string_of_bytes(buf);
     throw caml_maybe_attach_backtrace(_hk_, 0);
    }
    var buf$2 = ensure(buf, nread, 65537);
    caml_bytes_set(buf$2, nread, c);
    var ofs$1 = nread + 1 | 0, buf$0 = buf$2, ofs = ofs$1;
    for(;;){
     var
      buf$1 = ensure(buf$0, ofs, chunk_size),
      rem = caml_ml_bytes_length(buf$1) - ofs | 0,
      r = read_upto(ic, buf$1, ofs, rem);
     if(r < rem) return sub_string(buf$1, 0, ofs + r | 0);
     var ofs$0 = ofs + rem | 0;
     buf$0 = buf$1;
     ofs = ofs$0;
    }
   }
   var _bT_ = "Digest.BLAKE2: wrong hash size";
   function BLAKE2(X){
    var _hg_ = X[1] < 1 ? 1 : 0, _hh_ = _hg_ || (64 < X[1] ? 1 : 0);
    if(_hh_) invalid_arg(_bT_);
   }
   BLAKE2([0, 16]);
   BLAKE2([0, 32]);
   BLAKE2([0, 64]);
   function bytes(b){
    var str = caml_string_of_bytes(b);
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   var
    _bU_ = caml_int64_create_lo_mi_hi(1, 0, 0),
    _bV_ = caml_int64_create_lo_mi_hi(0, 0, 0),
    _bW_ = caml_int64_create_lo_mi_hi(0, 0, 0),
    _bX_ = caml_int64_create_lo_mi_hi(2, 0, 0),
    _bY_ = caml_int64_create_lo_mi_hi(1, 0, 0);
   function create$1(param){return caml_ba_create(7, 0, [0, 4]);}
   function set$0(s, i1, i2, i3, i4){
    caml_ba_set_1(s, 0, caml_int64_or(i1, _bU_));
    caml_ba_set_1(s, 1, i2);
    var i3$0 = caml_notequal(i3, _bV_) ? i3 : _bY_;
    caml_ba_set_1(s, 2, i3$0);
    var i4$0 = caml_notequal(i4, _bW_) ? i4 : _bX_;
    caml_ba_set_1(s, 3, i4$0);
   }
   function mk(i1, i2, i3, i4){
    var s = create$1(0);
    set$0(s, i1, i2, i3, i4);
    return s;
   }
   function make_self_init(param){
    var
     seed = caml_sys_random_seed(0),
     s = create$1(0),
     n = seed.length - 1,
     b = caml_create_bytes((n * 8 | 0) + 1 | 0),
     _hb_ = n - 1 | 0,
     _ha_ = 0;
    if(_hb_ >= 0){
     var i = _ha_;
     for(;;){
      var
       x = caml_int64_of_int32(caml_check_bound(seed, i)[1 + i]),
       i$0 = i * 8 | 0;
      caml_bytes_set64(b, i$0, x);
      var _hf_ = i + 1 | 0;
      if(_hb_ === i) break;
      i = _hf_;
     }
    }
    caml_bytes_set(b, n * 8 | 0, 1);
    var d1 = bytes(b);
    caml_bytes_set(b, n * 8 | 0, 2);
    var
     d2 = bytes(b),
     _hc_ = get_int64_le(d2, 8),
     _hd_ = get_int64_le(d2, 0),
     _he_ = get_int64_le(d1, 8);
    set$0(s, get_int64_le(d1, 0), _he_, _hd_, _hc_);
    return s;
   }
   var
    _bZ_ = caml_int64_create_lo_mi_hi(14371852, 15349651, 22696),
    _b0_ = caml_int64_create_lo_mi_hi(12230193, 11438743, 35013),
    _b1_ = caml_int64_create_lo_mi_hi(1424933, 15549263, 2083),
    _b2_ = caml_int64_create_lo_mi_hi(9492471, 4696708, 43520);
   function split(s){
    var
     i1 = caml_lxm_next(s),
     i2 = caml_lxm_next(s),
     i3 = caml_lxm_next(s),
     i4 = caml_lxm_next(s);
    return mk(i1, i2, i3, i4);
   }
   function mk_default(param){return mk(_b2_, _b1_, _b0_, _bZ_);}
   new_key([0, split], mk_default);
   var
    _q_ = cst_tl,
    _D_ = "first domain already spawned",
    _b7_ = "Hashtbl: unsupported hash table format",
    _b5_ = cst,
    _ch_ = [3, 0, 3],
    _ci_ = cst$3,
    _cg_ = cst,
    _cf_ = cst,
    _ce_ = cst$4,
    _cd_ = [0, cst],
    _b$_ = cst,
    _ca_ = cst,
    _cb_ = cst,
    _cc_ = cst,
    _b9_ = "Stdlib.Format.String_tag",
    _co_ = cst,
    _cn_ = cst,
    _ck_ = "/tmp",
    _cm_ = cst$3,
    _cr_ =
      [0,
       [11, "Stdlib.Effect.Unhandled(", [2, 0, [12, 41, 0]]],
       "Stdlib.Effect.Unhandled(%s)"],
    _cp_ = "Stdlib.Effect.Unhandled",
    _cq_ = "Stdlib.Effect.Continuation_already_resumed",
    _cs_ = "Stdlib.Effect.Should_not_see_this__",
    _ct_ = "Effect.Unhandled",
    _cu_ = "Effect.Continuation_already_resumed",
    _cw_ =
      "%%DUNE_PLACEHOLDER:4096:hardcoded_ocaml_path:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
    _cx_ = "dune error: hardcoded_ocamlpath parsing error",
    _d6_ =
      [0,
       [11, "Invalid value ", [2, 0, [12, 61, [3, 0, 0]]]],
       "Invalid value %s=%S"],
    _cF_ = cst$6,
    _cD_ = "[",
    _cE_ = cst$6,
    _cG_ = cst$6,
    _cH_ = cst_true$0,
    _cI_ = cst_false$0,
    _cJ_ = cst$6,
    _cK_ = cst_true$0,
    _cL_ = cst_false$0,
    _cM_ = cst$6,
    _dw_ = cst_true,
    _dx_ = [0, [2, 1]],
    _dy_ = cst_false,
    _dz_ = [0, [2, 0]],
    _dA_ = "Unexpected Word Configuration",
    _dB_ = "Empty Module Configuration",
    _dC_ = cst_Bad_function_definition,
    _dD_ = cst_Bad_function_definition,
    _dO_ = cst_take,
    _dN_ = "Expected a Quote of Word and Tokens",
    _dL_ = "Expected a Quote of Strings or Chars",
    _dM_ = cst,
    _dJ_ = cst_Expected_a_Word_or_String_,
    _dK_ = cst_Expected_a_Word_or_String_,
    _dE_ = "\t",
    _dF_ = cst$4,
    _dG_ = "\x0b",
    _dH_ = "\f",
    _dI_ = "\r",
    _dP_ = cst,
    _du_ = cst_Expected_end_of_string_not,
    _dv_ = cst_Expected_end_of_string_not,
    _dt_ = "Expected end of comment, not EOF",
    _ds_ = "Number is too large",
    _dn_ = "a q -> q[a ..]",
    _do_ = cst_a_a_a,
    _dp_ = cst_a_a_a,
    _dq_ = cst_a_a_a,
    _dr_ = cst_a_a_a,
    _di_ = cst_a_a,
    _dj_ = cst_a_a_a,
    _dk_ = cst_a,
    _dl_ = cst_a_a_a,
    _dm_ = "! -> s",
    _c__ = "a -> a a",
    _c$_ = "q[v] | s/v -> s",
    _da_ = "s/word -> !",
    _db_ = "qs -> s",
    _dc_ = "s -> qs",
    _dd_ = "q[v ..] -> !",
    _de_ = cst$14,
    _df_ = cst_a_a,
    _dg_ = cst_a_a,
    _dh_ = cst_a_a,
    _c0_ = "s/filecontent s/filename -> !",
    _c1_ = cst$14,
    _c2_ = "q -> !!",
    _c3_ = "? -> ?",
    _c4_ = "-> i",
    _c5_ = "s/filename -> s/filecontent",
    _c6_ = "q q b -> !!",
    _c7_ = cst_q_a,
    _c8_ = "-> !",
    _cQ_ = cst_s_filename,
    _cR_ = cst_s_filename,
    _cS_ = cst_q_q,
    _cT_ = "a b -> b a",
    _cU_ = cst_q_q,
    _cV_ = cst_q_a,
    _cW_ = "a b c -> b c a",
    _cX_ = "a -> q[a]",
    _cY_ = cst_a,
    _cZ_ = "a b -> a b a",
    _c9_ = "s/code -> !!",
    _cP_ = cst,
    _cN_ = "Forthish.Parser.Module.Parse_err",
    _cO_ = "Forthish.Parser.Module.Eval_err",
    _dQ_ = "Jsoo_runtime.Error.Exn",
    _dR_ = "jsError",
    _dS_ = "[\\][()\\\\|+*.?{}^$]",
    _dT_ = "Js_of_ocaml__Url.Local_exn",
    _d4_ = [0, cst_web_main_ml, 225, 17],
    _d3_ = [0, cst_web_main_ml, 220, 17],
    _d5_ = cst,
    _dX_ = cst,
    _dY_ = "Err! No Such Definition",
    _dZ_ = "Err! Empty Stack",
    _d0_ = "Err! Division by Zero",
    _d1_ = "Cannot Exit the Browser",
    _d2_ = "Unknown Failure",
    _dW_ = cst,
    max_int = 2147483647;
   try{var _d__ = caml_sys_getenv("OCAMLRUNPARAM"), params = _d__;}
   catch(_g__){
    var _b3_ = caml_wrap_exception(_g__);
    if(_b3_ !== Not_found) throw caml_maybe_attach_backtrace(_b3_, 0);
    try{var _d9_ = caml_sys_getenv("CAMLRUNPARAM"), _b6_ = _d9_;}
    catch(_g$_){
     var _b4_ = caml_wrap_exception(_g$_);
     if(_b4_ !== Not_found) throw caml_maybe_attach_backtrace(_b4_, 0);
     var _b6_ = _b5_;
    }
    var params = _b6_;
   }
   var
    randomized_default = contains(params, 82),
    randomized = [0, randomized_default],
    prng_key = new_key(0, make_self_init);
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : invalid_arg(_b7_);
   }
   var zero = 0, unknown = -1, String_tag = [248, _b9_, caml_fresh_oo_id(0)];
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return add(token, state[28]);
   }
   var pp_infinity = 1000000010;
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
   }
   function format_string(state, s){
    var _g9_ = s !== cst ? 1 : 0;
    return _g9_ ? format_pp_text(state, caml_ml_string_length(s), s) : _g9_;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = min(state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = top_opt(state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return caml_lessthan(n, x) ? [0, n, ls] : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        pop_opt(state[2]); return;
       case 2:
        pop_opt(state[3]); return;
       case 3:
        var match$4 = top_opt(state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_new_line(state, _b__, width$0);
       case 4:
        var _g7_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! _g7_) return _g7_;
        var q = state[28], _g6_ = q[2];
        if(_g6_){
         var content = _g6_[1];
         if(_g6_[2]){
          var next = _g6_[2];
          q[1] = q[1] - 1 | 0;
          q[2] = next;
          var match$1 = [0, content];
         }
         else{clear$0(q); var match$1 = [0, content];}
        }
        else
         var match$1 = 0;
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = pop_opt(state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = top_opt(state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 0:
          return break_same_line(state, fits);
         case 1:
          return break_new_line(state, breaks, width$1);
         case 2:
          return break_new_line(state, breaks, width$1);
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         default: return break_same_line(state, fits);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = top_opt(state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(param$0){
          var tail = param$0[2], head = param$0[1];
          if(insertion_point > head){param$0 = tail; continue;}
          var _g8_ = head;
         }
         else
          var _g8_ = first;
         var tab = _g8_;
         break;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, _ca_, offset + n | 0, _b$_])
               : break_new_line
                 (state, [0, _cc_, tab + off$0 | 0, _cb_], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = top_opt(state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_new_line(state, _b__, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return push([0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1]; return push(tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return push(tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var q = state[28], match = q[2];
     if(match)
      var content = match[1], match$0 = [0, content];
     else
      var match$0 = 0;
     if(! match$0) return;
     var
      match$1 = match$0[1],
      size = match$1[1],
      length = match$1[3],
      token = match$1[2],
      pending_count = state[13] - state[12] | 0,
      _g4_ = 0 <= size ? 1 : 0,
      _g5_ = _g4_ || (state[9] <= pending_count ? 1 : 0);
     if(! _g5_) return _g5_;
     var q$0 = state[28], _g3_ = q$0[2];
     if(! _g3_) throw caml_maybe_attach_backtrace(Empty$0, 1);
     if(_g3_[2]){
      var next = _g3_[2];
      q$0[1] = q$0[1] - 1 | 0;
      q$0[2] = next;
     }
     else
      clear$0(q$0);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function initialize_scan_stack(stack){
    clear(stack);
    var queue_elem = [0, unknown, _cd_, 0];
    return push([0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = top_opt(state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var _g2_ = queue_elem[2];
    if(typeof _g2_ !== "number")
     switch(_g2_[0]){
       case 3:
        if(1 - ty){
         var x$0 = state[13] + size | 0;
         queue_elem[1] = x$0;
         pop_opt(state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         var x = state[13] + size | 0;
         queue_elem[1] = x;
         pop_opt(state[1]);
        }
        return;
     }
   }
   function pp_print_flush(state, param){
    var s$0 = state[4];
    function f(param){
     if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
     var _g0_ = state[22];
     if(_g0_){
      var match = pop_opt(state[4]);
      if(match){
       var tag_name = match[1];
       return caml_call1(state[27], tag_name);
      }
      var _g1_ = 0;
     }
     else
      var _g1_ = _g0_;
     return _g1_;
    }
    iter(f, s$0[1]);
    for(;;){
     if(1 >= state[14]) break;
     if(1 < state[14]){
      if(state[14] < state[15]){
       pp_enqueue(state, [0, zero, 1, 0]);
       set_size(state, 1);
       set_size(state, 0);
      }
      state[14] = state[14] - 1 | 0;
     }
    }
    state[13] = pp_infinity;
    advance_left(state);
    state[12] = 1;
    state[13] = 1;
    clear$0(state[28]);
    initialize_scan_stack(state[1]);
    clear(state[2]);
    clear(state[3]);
    clear(state[4]);
    clear(state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    state[14] = state[14] + 1 | 0;
    var br_ty = 3, indent = 0;
    if(state[14] < state[15]){
     var size$0 = - state[13] | 0, token = [0, size$0, [3, indent, br_ty], 0];
     pp_enqueue(state, token);
     var elem = [0, state[13], token];
     push(elem, state[1]);
    }
    else if(state[14] === state[15]){
     var
      s = state[16],
      size = caml_ml_string_length(s),
      tok = [0, size, [0, s], size];
     pp_enqueue(state, tok);
     advance_left(state);
    }
    return caml_call1(state[18], 0);
   }
   function display_newline(state, param){
    return caml_call3(state[17], _ce_, 0, 1);
   }
   var blank_line = make$0(80, 32);
   function display_blanks(state, n){
    var n$0 = n;
    for(;;){
     var _gZ_ = 0 < n$0 ? 1 : 0;
     if(! _gZ_) return _gZ_;
     if(80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
     caml_call3(state[17], blank_line, 0, 80);
     var n$1 = n$0 - 80 | 0;
     n$0 = n$1;
    }
   }
   function default_pp_mark_open_tag(param){
    if(param[1] !== String_tag) return _cf_;
    var s1 = param[2], s2 = s1 + cst$15;
    return cst$16 + s2;
   }
   function default_pp_mark_close_tag(param){
    if(param[1] !== String_tag) return _cg_;
    var s1 = param[2], s2 = s1 + cst$15;
    return "<\/" + s2;
   }
   function default_pp_print_open_tag(_gY_){return 0;}
   function default_pp_print_close_tag(_gX_){return 0;}
   function pp_make_formatter(f, g, h, i, j){
    var pp_queue = [0, 0, 0, 0], sys_tok = [0, unknown, _ch_, 0];
    add(sys_tok, pp_queue);
    var scan_stack = create(0);
    initialize_scan_stack(scan_stack);
    push([0, 1, sys_tok], scan_stack);
    var pp_margin = 78, _gU_ = create(0), _gV_ = create(0), _gW_ = create(0);
    return [0,
            scan_stack,
            create(0),
            _gW_,
            _gV_,
            _gU_,
            pp_margin,
            10,
            68,
            pp_margin,
            0,
            1,
            1,
            1,
            1,
            max_int,
            _ci_,
            f,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function make_formatter(output, flush){
    var
     ppf =
       pp_make_formatter
        (output,
         flush,
         function(_gT_){return 0;},
         function(_gS_){return 0;},
         function(_gR_){return 0;});
    ppf[19] = function(_gQ_){return display_newline(ppf, _gQ_);};
    ppf[20] = function(_gP_){return display_blanks(ppf, _gP_);};
    ppf[21] = function(_gO_){return display_blanks(ppf, _gO_);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    return make_formatter
            (function(_gL_, _gM_, _gN_){
              return output_substring(oc, _gL_, _gM_, _gN_);
             },
             function(param){return caml_ml_flush(oc);});
   }
   function formatter_of_buffer(b){
    return make_formatter
            (function(_gI_, _gJ_, _gK_){
              return add_substring(b, _gI_, _gJ_, _gK_);
             },
             function(_gH_){return 0;});
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){return create$0(pp_buffer_size);}
   var
    stdbuf = create$0(pp_buffer_size),
    std_formatter = formatter_of_out_channel(stdout),
    err_formatter = formatter_of_out_channel(stderr),
    str_formatter = formatter_of_buffer(stdbuf),
    stdbuf_key = new_key(0, pp_make_buffer);
   set(stdbuf_key, stdbuf);
   var
    str_formatter_key =
      new_key
       (0, function(param){return formatter_of_buffer(get(stdbuf_key));});
   set(str_formatter_key, str_formatter);
   function buffered_out_string(key, str, ofs, len){return add_substring(get(key), str, ofs, len);
   }
   function buffered_out_flush(oc, key, param){
    var buf = get(key), len = buf[2], str = contents(buf);
    output_substring(oc, str, 0, len);
    caml_ml_flush(oc);
    buf[2] = 0;
    return 0;
   }
   var
    std_buf_key =
      new_key(0, function(param){return create$0(pp_buffer_size);}),
    err_buf_key =
      new_key(0, function(param){return create$0(pp_buffer_size);}),
    std_formatter_key =
      new_key
       (0,
        function(param){
         var
          ppf =
            pp_make_formatter
             (function(_gE_, _gF_, _gG_){
               return buffered_out_string(std_buf_key, _gE_, _gF_, _gG_);
              },
              function(_gD_){
               return buffered_out_flush(stdout, std_buf_key, _gD_);
              },
              function(_gC_){return 0;},
              function(_gB_){return 0;},
              function(_gA_){return 0;});
         ppf[19] = function(_gz_){return display_newline(ppf, _gz_);};
         ppf[20] = function(_gy_){return display_blanks(ppf, _gy_);};
         ppf[21] = function(_gx_){return display_blanks(ppf, _gx_);};
         at_exit(function(_gw_){return pp_print_flush(ppf, _gw_);});
         return ppf;
        });
   set(std_formatter_key, std_formatter);
   var
    err_formatter_key =
      new_key
       (0,
        function(param){
         var
          ppf =
            pp_make_formatter
             (function(_gt_, _gu_, _gv_){
               return buffered_out_string(err_buf_key, _gt_, _gu_, _gv_);
              },
              function(_gs_){
               return buffered_out_flush(stderr, err_buf_key, _gs_);
              },
              function(_gr_){return 0;},
              function(_gq_){return 0;},
              function(_gp_){return 0;});
         ppf[19] = function(_go_){return display_newline(ppf, _go_);};
         ppf[20] = function(_gn_){return display_blanks(ppf, _gn_);};
         ppf[21] = function(_gm_){return display_blanks(ppf, _gm_);};
         at_exit(function(_gl_){return pp_print_flush(ppf, _gl_);});
         return ppf;
        });
   set(err_formatter_key, err_formatter);
   for(;;){
    var f_yet_to_run = [0, 1], old_exit = caml_atomic_load(exit_function);
    let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
    var
     new_exit =
       function(param){
        if(caml_atomic_cas(f_yet_to_run$0, 1, 0)){
         pp_print_flush(get(std_formatter_key), 0);
         pp_print_flush(get(err_formatter_key), 0);
        }
        return caml_call1(old_exit$0, 0);
       },
     success = caml_atomic_cas(exit_function, old_exit, new_exit);
    if(! (1 - success)) break;
   }
   if(caml_atomic_load(first_domain_spawned))
    throw caml_maybe_attach_backtrace([0, Invalid_argument, _D_], 1);
   function register_exception(name, exn){
    var slot = caml_obj_tag(exn) === 248 ? exn : exn[1];
    caml_register_named_value(name, slot);
   }
   function generic_basename(is_dir_sep, current_dir_name, name){
    if(name === cst) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for(;;){
     if(0 > n) return sub$0(name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    var p = n + 1 | 0, n$1 = n;
    for(;;){
     if(0 > n$1) return sub$0(name, 0, p);
     if(caml_call2(is_dir_sep, name, n$1))
      return sub$0(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
   }
   function generic_dirname(is_dir_sep, current_dir_name, name){
    if(name === cst) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for(;;){
     if(0 > n) return sub$0(name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    var n$1 = n;
    for(;;){
     if(0 > n$1) return current_dir_name;
     if(caml_call2(is_dir_sep, name, n$1)) break;
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
    var n$3 = n$1;
    for(;;){
     if(0 > n$3) return sub$0(name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n$3))
      return sub$0(name, 0, n$3 + 1 | 0);
     var n$4 = n$3 - 1 | 0;
     n$3 = n$4;
    }
   }
   function is_dir_sep(s, i){return 47 === caml_string_get(s, i) ? 1 : 0;}
   try{var _d8_ = caml_sys_getenv("TMPDIR"), temp_dir_name = _d8_;}
   catch(_gk_){
    var _cj_ = caml_wrap_exception(_gk_);
    if(_cj_ !== Not_found) throw caml_maybe_attach_backtrace(_cj_, 0);
    var temp_dir_name = _ck_;
   }
   function basename(_gj_){
    return generic_basename(is_dir_sep, current_dir_name, _gj_);
   }
   function dirname(_gi_){
    return generic_dirname(is_dir_sep, current_dir_name, _gi_);
   }
   var
    Unix =
      [0,
       ,
       ,
       ,
       dir_sep,
       is_dir_sep,
       ,
       ,
       ,
       ,
       temp_dir_name,
       ,
       ,
       basename,
       dirname];
   function is_dir_sep$0(s, i){
    var c = caml_string_get(s, i), _gf_ = 47 === c ? 1 : 0;
    if(_gf_)
     var _gg_ = _gf_;
    else
     var _gh_ = 92 === c ? 1 : 0, _gg_ = _gh_ || (58 === c ? 1 : 0);
    return _gg_;
   }
   try{var _d7_ = caml_sys_getenv("TEMP"), temp_dir_name$0 = _d7_;}
   catch(_ge_){
    var _cl_ = caml_wrap_exception(_ge_);
    if(_cl_ !== Not_found) throw caml_maybe_attach_backtrace(_cl_, 0);
    var temp_dir_name$0 = _cm_;
   }
   function drive_and_path(s){
    var _ga_ = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if(_ga_){
     var param = caml_string_get(s, 0);
     a:
     {
      b:
      {
       if(91 <= param){
        if(25 < param - 97 >>> 0) break b;
       }
       else if(65 > param) break b;
       var _gb_ = 1;
       break a;
      }
      var _gb_ = 0;
     }
     var _gc_ = _gb_ ? 58 === caml_string_get(s, 1) ? 1 : 0 : _gb_;
    }
    else
     var _gc_ = _ga_;
    if(! _gc_) return [0, _cn_, s];
    var _gd_ = sub$0(s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, sub$0(s, 0, 2), _gd_];
   }
   function dirname$0(s){
    var
     match = drive_and_path(s),
     path = match[2],
     drive = match[1],
     dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return drive + dir;
   }
   function basename$0(s){
    var path = drive_and_path(s)[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path);
   }
   var
    Win32 =
      [0,
       ,
       ,
       ,
       dir_sep$0,
       is_dir_sep$0,
       ,
       ,
       ,
       ,
       temp_dir_name$0,
       ,
       ,
       basename$0,
       dirname$0];
   function basename$1(_f$_){
    return generic_basename(is_dir_sep$0, current_dir_name$1, _f$_);
   }
   function dirname$1(_f__){
    return generic_dirname(is_dir_sep$0, current_dir_name$1, _f__);
   }
   var
    Cygwin =
      [0,
       ,
       ,
       ,
       dir_sep$1,
       is_dir_sep$0,
       ,
       ,
       ,
       ,
       temp_dir_name,
       ,
       ,
       basename$1,
       dirname$1],
    Sysdeps =
      os_type$0 !== "Cygwin" ? os_type$0 !== "Win32" ? Unix : Win32 : Cygwin,
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    temp_dir_name$1 = Sysdeps[10],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
   function concat$0(dirname, filename){
    var l = caml_ml_string_length(dirname);
    if(0 !== l && ! is_dir_sep$1(dirname, l - 1 | 0)){
     var s2 = dir_sep$2 + filename;
     return dirname + s2;
    }
    return dirname + filename;
   }
   function extension_len(name){
    var i$3 = caml_ml_string_length(name) - 1 | 0, i0 = i$3;
    for(;;){
     if(0 <= i0 && ! is_dir_sep$1(name, i0)){
      if(46 === caml_string_get(name, i0)) break;
      var i$2 = i0 - 1 | 0;
      i0 = i$2;
      continue;
     }
     return 0;
    }
    var i$1 = i0 - 1 | 0, i = i$1;
    for(;;){
     if(0 <= i && ! is_dir_sep$1(name, i)){
      if(46 !== caml_string_get(name, i))
       return caml_ml_string_length(name) - i0 | 0;
      var i$0 = i - 1 | 0;
      i = i$0;
      continue;
     }
     return 0;
    }
   }
   new_key(0, make_self_init);
   new_key
    ([0, function(_f9_){return _f9_;}],
     function(param){return temp_dir_name$1;});
   var
    Unhandled = [248, _cp_, caml_fresh_oo_id(0)],
    Continuation_already_resumed = [248, _cq_, caml_fresh_oo_id(0)];
   function printer(param){
    if(param[1] !== Unhandled) return 0;
    var
     x = param[2],
     _f8_ = string_of_extension_constructo(x),
     msg = caml_call1(sprintf(_cr_), _f8_);
    return [0, msg];
   }
   register_printer(printer);
   var Should_not_see_this = [248, _cs_, caml_fresh_oo_id(0)];
   register_exception(_ct_, [0, Unhandled, Should_not_see_this]);
   register_exception(_cu_, Continuation_already_resumed);
   var path_sep = win32 ? 59 : 58, random = caml_atomic_load(randomized);
   a:
   b:
   {
    var x = 16;
    for(;;){
     if(10 <= x) break b;
     if(max_array_length < (x * 2 | 0)) break;
     var x$0 = x * 2 | 0;
     x = x$0;
    }
    break a;
   }
   if(random)
    var
     s = get(prng_key),
     seed = caml_int64_to_int32(caml_lxm_next(s)) & 1073741823;
   else
    var seed = 0;
   var dirs = [0, 0, caml_make_vect(x, 0), seed, x];
   try{var _g_ = [0, caml_sys_getenv(cst_DUNE_DIR_LOCATIONS)], match$2 = _g_;}
   catch(_f7_){
    var _f_ = caml_wrap_exception(_f7_);
    if(_f_ !== Not_found) throw caml_maybe_attach_backtrace(_f_, 0);
    var match$2 = 0;
   }
   if(match$2){
    var s$2 = match$2[1], l$0 = split_on_char(path_sep, s$2);
    a:
    {
     b:
     c:
     {
      d:
      {
       var acc = 0, param$2 = l$0;
       for(;;){
        if(! param$2) break;
        var _cv_ = param$2[2];
        if(! _cv_) break d;
        var match$1 = _cv_[2];
        if(! match$1) break c;
        var
         l = match$1[2],
         dir = match$1[1],
         section = _cv_[1],
         package$0 = param$2[1];
        e:
        {
         f:
         {
          var param$1 = all;
          for(;;){
           if(! param$1) break;
           var
            xs = param$1[2],
            match = param$1[1],
            x$1 = match[2],
            s$0 = match[1];
           if(caml_equal(x$1, section)) break f;
           param$1 = xs;
          }
          var match$0 = 0;
          break e;
         }
         var match$0 = [0, s$0];
        }
        if(match$0)
         var s$1 = match$0[1], section$0 = s$1;
        else
         var section$0 = invalid_arg("Dune-site: Unknown section " + section);
        var acc$0 = [0, [0, package$0, section$0, dir], acc];
        acc = acc$0;
        param$2 = l;
       }
       var match$3 = [0, rev(acc)];
       break a;
      }
      break b;
     }
     var match$3 = 0;
    }
    if(match$3){
     var entries = match$3[1];
     iter
      (function(param){
        var
         data$0 = param[3],
         section = param[2],
         package$0 = param[1],
         key$0 = [0, package$0, section],
         i$1 = key_index(dirs, key$0),
         bucket = [0, key$0, data$0, caml_check_bound(dirs[2], i$1)[1 + i$1]];
        caml_check_bound(dirs[2], i$1)[1 + i$1] = bucket;
        dirs[1] = dirs[1] + 1 | 0;
        var _f6_ = dirs[2].length - 1 << 1 < dirs[1] ? 1 : 0;
        if(! _f6_) return _f6_;
        var
         odata = dirs[2],
         osize = odata.length - 1,
         nsize$0 = osize * 2 | 0,
         _f5_ = nsize$0 < max_array_length ? 1 : 0;
        if(! _f5_) return _f5_;
        var
         ndata = caml_make_vect(nsize$0, 0),
         _fW_ = dirs.length - 1 < 4 ? 1 : 0,
         _fX_ = _fW_ || (dirs[4] < 0 ? 1 : 0),
         inplace = 1 - _fX_;
        dirs[2] = ndata;
        var
         nsize = ndata.length - 1,
         ndata_tail = caml_make_vect(nsize, 0),
         _fZ_ = odata.length - 2 | 0,
         _fY_ = 0;
        if(_fZ_ >= 0){
         var i$0 = _fY_;
         for(;;){
          var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
          for(;;){
           if(! cell) break;
           var
            key = cell[1],
            data = cell[2],
            next = cell[3],
            cell$0 = inplace ? cell : [0, key, data, 0],
            nidx = key_index(dirs, key),
            match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
           if(match)
            match[3] = cell$0;
           else
            caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
           caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
           cell = next;
          }
          var _f4_ = i$0 + 1 | 0;
          if(_fZ_ === i$0) break;
          i$0 = _f4_;
         }
        }
        if(inplace){
         var _f1_ = nsize - 1 | 0, _f0_ = 0;
         if(_f1_ >= 0){
          var i = _f0_;
          for(;;){
           var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
           if(match$0) match$0[3] = 0;
           var _f3_ = i + 1 | 0;
           if(_f1_ === i) break;
           i = _f3_;
          }
         }
         var _f2_ = 0;
        }
        else
         var _f2_ = inplace;
        return _f2_;
       },
       entries);
    }
    else
     invalid_arg(caml_call2(sprintf(_d6_), dune_dir_locations_env_var, s$2));
   }
   function eval$0(s){
    var len = caml_ml_string_length(s);
    if(61 !== caml_string_get(s, 0)) return 0;
    var
     colon_pos = index_from(s, 1, 58),
     vlen = caml_int_of_string(sub$0(s, 1, colon_pos - 1 | 0)),
     y = (len - colon_pos | 0) - 1 | 0,
     vlen$0 = caml_lessequal(vlen, y) ? vlen : y;
    return [0, sub$0(s, colon_pos + 1 | 0, vlen$0)];
   }
   var
    t =
      [246,
       function(param){
        var match = eval$0(_cw_);
        if(! match) return 0;
        var s = match[1];
        if(s === "relocatable") return 1;
        var l = split_on_char(0, s);
        if(l){
         var _fU_ = l[1];
         if(_fU_ !== "findlibconfig"){
          if(_fU_ === "hardcoded"){var l$0 = l[2]; return [0, l$0];}
         }
         else{
          var _fV_ = l[2];
          if(_fV_ && ! _fV_[2]){var p = _fV_[1]; return [1, p];}
         }
        }
        return invalid_arg(_cx_);
       }],
    relocatable =
      [246,
       function(_fR_){
        var _fS_ = caml_obj_tag(t);
        a:
        if(250 === _fS_)
         var _fT_ = t[1];
        else{
         if(246 !== _fS_ && 244 !== _fS_){var _fT_ = t; break a;}
         var _fT_ = force_lazy_block(t);
        }
        if(typeof _fT_ === "number" && _fT_) return 1;
        return 0;
       }],
    prefix =
      [246,
       function(param){
        var bin = dirname$2(executable_name), prefix = dirname$2(bin);
        return prefix;
       }],
    key = [0, package$1, 1],
    _b8_ = key_index(dirs, key);
   a:
   {
    b:
    {
     var param = caml_check_bound(dirs[2], _b8_)[1 + _b8_];
     for(;;){
      if(! param) break;
      var k = param[1], data = param[2], next = param[3];
      if(0 === caml_compare(k, key)) break b;
      param = next;
     }
     var dirs$0 = 0;
     break a;
    }
    var block = [0, data, 24029], dst = block, offset = 1, param$0 = next;
    for(;;){
     if(! param$0) break;
     var k$0 = param$0[1], data$0 = param$0[2], next$0 = param$0[3];
     if(0 === caml_compare(k$0, key)){
      var dst$0 = [0, data$0, 24029];
      dst[1 + offset] = dst$0;
      dst = dst$0;
      offset = 1;
      param$0 = next$0;
     }
     else
      param$0 = next$0;
    }
    dst[1 + offset] = 0;
    var dirs$0 = block;
   }
   var match$4 = eval$0(encoded);
   if(match$4){
    var path = match$4[1], _cy_ = caml_obj_tag(relocatable);
    a:
    if(250 === _cy_)
     var _cz_ = relocatable[1];
    else{
     if(246 !== _cy_ && 244 !== _cy_){var _cz_ = relocatable; break a;}
     var _cz_ = force_lazy_block(relocatable);
    }
    if(_cz_){
     var _cA_ = caml_obj_tag(prefix);
     a:
     if(250 === _cA_)
      var _cB_ = prefix[1];
     else{
      if(246 !== _cA_ && 244 !== _cA_){var _cB_ = prefix; break a;}
      var _cB_ = force_lazy_block(prefix);
     }
     var _cC_ = concat$0(_cB_, path);
    }
    else
     var _cC_ = path;
    var dirs$1 = [0, _cC_, dirs$0];
   }
   else
    var dirs$1 = dirs$0;
   var
    forthish_std =
      rev_map(function(dir){return concat$0(dir, suffix);}, dirs$1);
   function print_def(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number")
      switch(param$0){
        case 0:
         return output_string(stdout, s$3);
        case 1:
         return output_string(stdout, s$4);
        case 2:
         return output_string(stdout, s$5);
        default: return caml_ml_output_char(stdout, 63);
      }
     switch(param$0[0]){
       case 0:
        var c = param$0[1]; return caml_ml_output_char(stdout, c);
       case 1:
        var d = param$0[1]; output_string(stdout, s$6); param$0 = d; break;
       case 2:
        var m = param$0[1]; return iter(print_def, m);
       default: var o = param$0[2], i = param$0[1]; print_def(i); param$0 = o;
     }
    }
   }
   function string_of_tok(param){
    switch(param[0]){
      case 0:
       var match = param[1];
       switch(match[0]){
         case 0:
          var i = match[1]; return "" + i;
         case 1:
          var s = match[1]; return s;
         default: var b = match[1]; return string_of_bool(b);
       }
      case 1:
       var w = param[1]; return w;
      case 2:
       var
        q = param[1],
        s1$1 =
          fold_left
           (function(acc, s2){var s2$0 = cst$7 + s2; return acc + s2$0;},
            _cD_,
            map$0(string_of_tok, q));
       return s1$1 + " ]";
      case 3:
       var
        ts = param[3],
        s1 = param[1],
        s2$0 =
          fold_left
           (function(acc, s2){var s2$0 = cst$7 + s2; return acc + s2$0;},
            _cE_,
            rev_map(string_of_tok, ts));
       return s1 + s2$0;
      case 4:
       var
        ts$0 = param[2],
        s1$0 = param[1],
        ss = map$0(string_of_tok, ts$0),
        fold_right =
          function(f, l, accu){
           if(! l) return accu;
           var l$0 = l[2], a = l[1];
           return caml_call2(f, a, fold_right(f, l$0, accu));
          },
        s2 =
          fold_right
           (function(acc, s2){var s2$0 = cst$7 + s2; return acc + s2$0;},
            ss,
            _cF_);
       return s1$0 + s2;
      case 5:
       var s$0 = param[2], sl = param[1];
       return concat(_cG_, symbol(sl, [0, s$0, 0]));
      default: var c = param[1]; return c;
    }
   }
   function print_tok(param){
    switch(param[0]){
      case 0:
       var match = param[1];
       switch(match[0]){
         case 0:
          var i = match[1]; print_int(i); return output_string(stdout, s$7);
         case 1:
          var s1 = match[1], s2$0 = s1 + cst$17, s$5 = cst$18 + s2$0;
          return output_string(stdout, s$5);
         default:
          var b = match[1], s = b ? _cH_ : _cI_;
          return output_string(stdout, s);
       }
      case 1:
       var s1$0 = param[1], s$4 = s1$0 + cst$7;
       return output_string(stdout, s$4);
      case 2:
       var q = param[1];
       output_string(stdout, s$8);
       iter(print_tok, q);
       return output_string(stdout, s$9);
      case 3:
       var
        ts = param[3],
        d = param[2],
        s1$1 = param[1],
        s2 = s1$1 + cst$7,
        s$3 = cst$6 + s2;
       output_string(stdout, s$3);
       if(d){
        var d$0 = d[1];
        output_string(stdout, s$10);
        print_def(d$0);
        output_string(stdout, s$11);
       }
       iter(print_tok, rev(ts));
       return output_string(stdout, s$12);
      case 4:
       var ts$0 = param[2], s1$2 = param[1], s$2 = s1$2 + cst$2;
       output_string(stdout, s$2);
       iter(print_tok, rev(ts$0));
       return output_string(stdout, s$13);
      case 5:
       var
        s$0 = param[2],
        sl = param[1],
        s$1 = concat(_cJ_, symbol(sl, [0, s$0, 0]));
       output_string(stdout, s$1);
       return output_string(stdout, s$14);
      default:
       var c = param[1];
       output_string(stdout, s$15);
       output_string(stdout, c);
       return output_string(stdout, s$16);
    }
   }
   function print_fun(_fO_, opt){
    var tabul = _fO_ ? _fO_[1] : 0, tab = opt ? opt[1] : 0;
    if(tabul){var s = make$0(tab, 32); output_string(stdout, s);}
    return function(param){
     if(! param) return;
     var match = param[1];
     switch(match[0]){
       case 0:
        var match$0 = match[1];
        switch(match$0[0]){
          case 0:
           var ts = param[2], i = match$0[1];
           print_int(i);
           output_string(stdout, s$17);
           return print_fun(0, [0, tab])(ts);
          case 1:
           var
            ts$0 = param[2],
            s1 = match$0[1],
            s2$2 = s1 + cst$17,
            s$5 = cst$18 + s2$2;
           output_string(stdout, s$5);
           return print_fun(0, [0, tab])(ts$0);
          default:
           var ts$1 = param[2], b = match$0[1], s = b ? _cK_ : _cL_;
           output_string(stdout, s);
           return print_fun(0, [0, tab])(ts$1);
        }
       case 1:
        var ts$2 = param[2], s1$0 = match[1], s$4 = s1$0 + cst$7;
        output_string(stdout, s$4);
        return print_fun(0, [0, tab])(ts$2);
       case 2:
        var ts$3 = param[2], q = match[1];
        output_string(stdout, s$18);
        iter(print_tok, q);
        output_string(stdout, s$19);
        return print_fun(0, [0, tab])(ts$3);
       case 3:
        var
         ts$4 = param[2],
         ts$5 = match[3],
         d = match[2],
         s1$1 = match[1],
         s2$1 = s1$1 + cst$7,
         s2$0 = cst$6 + s2$1,
         s1$2 = make$0(tab, 32),
         s$3 = s1$2 + s2$0;
        output_string(stdout, s$3);
        if(d){
         var d$0 = d[1];
         output_string(stdout, s$20);
         print_def(d$0);
         output_string(stdout, s$21);
        }
        var _fP_ = rev(ts$5);
        print_fun(0, 0)(_fP_);
        output_string(stdout, s$22);
        return print_fun(0, [0, tab])(ts$4);
       case 4:
        var
         ts$6 = param[2],
         ts$7 = match[2],
         s1$3 = match[1],
         s2 = s1$3 + cst$2,
         s1$4 = make$0(tab, 32),
         s$2 = s1$4 + s2;
        output_string(stdout, s$2);
        var _fQ_ = rev(ts$7);
        print_fun(0, 0)(_fQ_);
        output_string(stdout, s$23);
        return print_fun(0, [0, tab])(ts$6);
       case 5:
        var
         ts$8 = param[2],
         s$0 = match[2],
         sl = match[1],
         s$1 = concat(_cM_, symbol(sl, [0, s$0, 0]));
        output_string(stdout, s$1);
        output_string(stdout, s$24);
        return print_fun(0, [0, tab])(ts$8);
       default:
        var ts$9 = param[2], c = match[1];
        output_string(stdout, s$25);
        output_string(stdout, c);
        output_string(stdout, s$26);
        return print_fun(0, [0, tab])(ts$9);
     }};
   }
   var
    Parse_err = [248, _cN_, caml_fresh_oo_id(0)],
    Eval_err = [248, _cO_, caml_fresh_oo_id(0)];
   function create$2(name){return [0, name, 0, 0, _cP_, 0];}
   function useup(_fM_, param){
    var
     modout = param[4],
     modls_b = param[3],
     lst_b = param[2],
     i = _fM_[5],
     out = _fM_[4],
     modls_a = _fM_[3],
     lst_a = _fM_[2],
     name_a = _fM_[1],
     _fN_ = symbol(modls_b, modls_a);
    return [0, name_a, symbol(lst_b, lst_a), _fN_, modout + out, i];
   }
   function use(param, modl){
    var
     i = param[5],
     out = param[4],
     modls = param[3],
     lst = param[2],
     name = param[1];
    return [0, name, lst, [0, modl, modls], out, i];
   }
   function add$0(param, def){
    var
     i = param[5],
     out = param[4],
     modls = param[3],
     lst = param[2],
     name = param[1];
    return [0, name, [0, def, lst], modls, out, i];
   }
   function find_opt(param$0, def_name){
    var lst = param$0[2], param = lst;
    for(;;){
     if(! param) return 0;
     var l = param[2], match = param[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, def_name)) return [0, b];
     param = l;
    }
   }
   function find_modl(param$0, modl_name){
    var modls = param$0[3], param = modls;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Not_found, 1);
     var l = param[2], x = param[1], name = x[1];
     if(name === modl_name) return x;
     param = l;
    }
   }
   function incl(param){
    var
     i = param[5],
     out = param[4],
     modls = param[3],
     lst = param[2],
     name = param[1];
    return [0, name, lst, modls, out, i + 1 | 0];
   }
   function add_out(param, print){
    var
     i = param[5],
     out = param[4],
     modls = param[3],
     lst = param[2],
     name = param[1];
    return [0, name, lst, modls, out + print, i];
   }
   function eval_err(param, s){
    var i = param[5], o = param[4], m = param[3], l = param[2], n = param[1];
    throw caml_maybe_attach_backtrace
           ([0, Eval_err, s, [0, n, l, m, o, i + 1 | 0]], 1);
   }
   function parse_err(param, s){
    var i = param[5], o = param[4], m = param[3], l = param[2], n = param[1];
    throw caml_maybe_attach_backtrace
           ([0, Parse_err, s, [0, n, l, m, o, i + 1 | 0]], 1);
   }
   var stack = create(0);
   function pop(modl, s1){
    var match = pop_opt(stack);
    if(match){var v = match[1]; return v;}
    var s2 = s1 + cst_expected_another_Argument_;
    return eval_err(modl, cst_Function + s2);
   }
   function top(modl, s1){
    var match = top_opt(stack);
    if(match){var v = match[1]; return v;}
    var s2 = s1 + cst_expected_another_Argument_;
    return eval_err(modl, cst_Function + s2);
   }
   function err(a, modl, s){push(a, stack); return eval_err(modl, s);}
   function match_bool(f, modl, name){
    var a = pop(modl, name);
    if(0 === a[0]){
     var match = a[1];
     if(2 === match[0]){var b = match[1]; return caml_call1(f, b);}
    }
    var s2 = name + " expected a Bool Argument";
    return err(a, modl, cst_Function + s2);
   }
   function match_int(f, modl, name){
    var a = pop(modl, name);
    if(0 === a[0]){
     var match = a[1];
     if(0 === match[0]){var x = match[1]; return caml_call1(f, x);}
    }
    var s2 = name + " expected an Int Argument";
    return err(a, modl, cst_Function + s2);
   }
   function match_str(f, modl, name){
    var a = pop(modl, name);
    if(0 === a[0]){
     var match = a[1];
     if(1 === match[0]){var s = match[1]; return caml_call1(f, s);}
    }
    var s2 = name + " expected a String Argument";
    return err(a, modl, cst_Function + s2);
   }
   function match_quote(f, modl, name){
    var a = pop(modl, name);
    if(2 === a[0]){var q = a[1]; return caml_call1(f, q);}
    var s2 = name + " expected a Quote Argument";
    return err(a, modl, cst_Function + s2);
   }
   function match_nonempty_quote(f, modl, name){
    var a = pop(modl, name);
    if(2 !== a[0]){
     var s2 = name + cst_expected_a_Non_Empty_Quote;
     return err(a, modl, cst_Function + s2);
    }
    var q = a[1];
    if(q) return caml_call1(f, q);
    var s2$0 = name + cst_expected_a_Non_Empty_Quote;
    return eval_err(modl, cst_Function + s2$0);
   }
   function bop(f, modl, name){
    return match_bool
            (function(y){
              return match_bool
                      (function(x){
                        var x$0 = [0, [2, caml_call2(f, x, y)]];
                        return push(x$0, stack);
                       },
                       modl,
                       name);
             },
             modl,
             name);
   }
   function iop(f, modl, name){
    return match_int
            (function(y){
              return match_int
                      (function(x){
                        var x$0 = [0, [0, caml_call2(f, x, y)]];
                        return push(x$0, stack);
                       },
                       modl,
                       name);
             },
             modl,
             name);
   }
   function isop_bool(f, g, modl, name){
    var a = pop(modl, name);
    if(0 === a[0]){
     var match = a[1];
     switch(match[0]){
       case 0:
        var y = match[1];
        return match_int
                (function(x){
                  var x$0 = [0, [2, caml_call2(f, x, y)]];
                  return push(x$0, stack);
                 },
                 modl,
                 name);
       case 1:
        var d = match[1];
        return match_str
                (function(s){
                  var x = [0, [2, caml_call2(g, s, d)]];
                  return push(x, stack);
                 },
                 modl,
                 name);
     }
    }
    var s2 = name + cst_expected_either_Ints_or_St;
    return err(a, modl, cst_Function + s2);
   }
   function isbqop_bool(f, g, h, j, modl, name){
    var a = pop(modl, name);
    switch(a[0]){
      case 0:
       var match = a[1];
       switch(match[0]){
         case 0:
          var y = match[1];
          return match_int
                  (function(x){
                    var x$0 = [0, [2, caml_call2(f, x, y)]];
                    return push(x$0, stack);
                   },
                   modl,
                   name);
         case 1:
          var d = match[1];
          return match_str
                  (function(s){
                    var x = [0, [2, caml_call2(g, s, d)]];
                    return push(x, stack);
                   },
                   modl,
                   name);
         default:
          var n = match[1];
          return match_bool
                  (function(b){
                    var x = [0, [2, caml_call2(h, b, n)]];
                    return push(x, stack);
                   },
                   modl,
                   name);
       }
      case 2:
       var q = a[1];
       return match_quote
               (function(p){
                 var x = [0, [2, caml_call2(j, p, q)]];
                 return push(x, stack);
                },
                modl,
                name);
      default:
       var s2 = name + " expected either Ints, Strings or Bools";
       return err(a, modl, cst_Function + s2);
    }
   }
   function pow(a, n){
    if(0 === n) return 1;
    if(1 === n) return a;
    var b = pow(a, n / 2 | 0), _fL_ = 0 === (n % 2 | 0) ? 1 : a;
    return caml_mul(caml_mul(b, b), _fL_);
   }
   function uncurry3(f, param){
    var c = param[3], b = param[2], a = param[1];
    return caml_call3(f, a, b, c);
   }
   function map_a3(f, param){
    var c = param[3], b = param[2], a = param[1];
    return [0, caml_call1(f, a), b, c];
   }
   function int$0(modl, cs){
    function inn(modl, cs){
     if(cs){
      var d = cs[1];
      if(10 === d){
       var cs$0 = cs[2], _fK_ = caml_call1(cs$0, 0);
       return [0, 0, incl(modl), _fK_];
      }
      if(48 <= d){
       if(58 > d){
        var
         cs$1 = cs[2],
         param = inn(modl, caml_call1(cs$1, 0)),
         c = param[3],
         b = param[2],
         a = param[1];
        return [0, [0, d, function(param){return a;}], b, c];
       }
      }
      else if(32 === d){
       var cs$2 = cs[2];
       return [0, 0, modl, caml_call1(cs$2, 0)];
      }
     }
     return [0, 0, modl, cs];
    }
    return map_a3
            (function(seq){
              var s = of_seq(function(param){return seq;});
              try{var _fH_ = [0, caml_int_of_string(s)], param = _fH_;}
              catch(_fJ_){
               var _fG_ = caml_wrap_exception(_fJ_);
               if(_fG_[1] !== Failure)
                throw caml_maybe_attach_backtrace(_fG_, 0);
               var param = 0;
              }
              if(param)
               var v = param[1], _fI_ = v;
              else
               var _fI_ = parse_err(modl, _ds_);
              return [0, [0, _fI_]];
             },
             inn(modl, cs));
   }
   function comm(modl, cs){
    function inn(acc, modl, param){
     var acc$0 = acc, modl$0 = modl, param$0 = param;
     for(;;){
      if(! param$0) return parse_err(modl$0, _dt_);
      var c = param$0[1], switcher = c - 40 | 0;
      if(1 >= switcher >>> 0){
       if(switcher){
        var cs$1 = param$0[2], _fF_ = caml_call1(cs$1, 0);
        return [0, rev(acc$0), modl$0, _fF_];
       }
       var cs$2 = param$0[2];
       return uncurry3(inn, inn(acc$0, modl$0, caml_call1(cs$2, 0)));
      }
      if(-30 === switcher){
       var
        cs = param$0[2],
        param$1 = caml_call1(cs, 0),
        modl$1 = incl(modl$0);
       modl$0 = modl$1;
       param$0 = param$1;
      }
      else{
       var cs$0 = param$0[2], acc$1 = [0, c, acc$0];
       acc$0 = acc$1;
       param$0 = caml_call1(cs$0, 0);
      }
     }
    }
    return map_a3
            (function(seq){return [6, of_seq(to_seq(seq))];},
             inn(0, modl, caml_call1(cs, 0)));
   }
   function str(modl, cs){
    a:
    {
     b:
     {
      c:
      {
       var acc = 0, modl$0 = modl, param = caml_call1(cs, 0);
       for(;;){
        if(! param) break;
        var c = param[1];
        if(10 === c){
         var
          cs$0 = param[2],
          param$0 = caml_call1(cs$0, 0),
          modl$1 = incl(modl$0);
         modl$0 = modl$1;
         param = param$0;
        }
        else{
         if(34 === c) break c;
         if(92 === c){
          var cs$2 = param[2], match = caml_call1(cs$2, 0);
          if(! match) break b;
          var c$0 = match[1];
          if(34 === c$0){
           var cs$3 = match[2], acc$0 = [0, 34, acc];
           acc = acc$0;
           param = caml_call1(cs$3, 0);
          }
          else{
           if(92 <= c$0){
            if(119 > c$0)
             switch(c$0 - 92 | 0){
               case 0:
                var cs$5 = match[2], acc$2 = [0, 92, acc];
                acc = acc$2;
                param = caml_call1(cs$5, 0);
                continue;
               case 5:
                var cs$6 = match[2], acc$3 = [0, 7, acc];
                acc = acc$3;
                param = caml_call1(cs$6, 0);
                continue;
               case 6:
                var cs$7 = match[2], acc$4 = [0, 8, acc];
                acc = acc$4;
                param = caml_call1(cs$7, 0);
                continue;
               case 10:
                var cs$8 = match[2], acc$5 = [0, 12, acc];
                acc = acc$5;
                param = caml_call1(cs$8, 0);
                continue;
               case 18:
                var cs$9 = match[2], acc$6 = [0, 10, acc];
                acc = acc$6;
                param = caml_call1(cs$9, 0);
                continue;
               case 22:
                var cs$10 = match[2], acc$7 = [0, 13, acc];
                acc = acc$7;
                param = caml_call1(cs$10, 0);
                continue;
               case 24:
                var cs$11 = match[2], acc$8 = [0, 9, acc];
                acc = acc$8;
                param = caml_call1(cs$11, 0);
                continue;
               case 26:
                var cs$12 = match[2], acc$9 = [0, 11, acc];
                acc = acc$9;
                param = caml_call1(cs$12, 0);
                continue;
             }
           }
           else if(48 === c$0){
            var cs$13 = match[2], acc$10 = [0, 0, acc];
            acc = acc$10;
            param = caml_call1(cs$13, 0);
            continue;
           }
           var cs$4 = match[2], acc$1 = [0, c$0, acc];
           acc = acc$1;
           param = caml_call1(cs$4, 0);
          }
         }
         else{
          var cs$14 = param[2], acc$11 = [0, c, acc];
          acc = acc$11;
          param = caml_call1(cs$14, 0);
         }
        }
       }
       var _fE_ = parse_err(modl$0, _dv_);
       break a;
      }
      var
       cs$1 = param[2],
       _fD_ = caml_call1(cs$1, 0),
       _fE_ = [0, rev(acc), modl$0, _fD_];
      break a;
     }
     var _fE_ = parse_err(modl$0, _du_);
    }
    return map_a3(function(seq){return [0, [1, of_seq(to_seq(seq))]];}, _fE_);
   }
   function tru(modl, cs){
    var _fC_ = to_seq$0(_dw_);
    return 0
            ===
             compare
              (function(a, b){return a === b ? 0 : 1;},
               take(4, function(param){return cs;}),
               _fC_)
            ? [0,
              _dx_,
              modl,
              caml_call1(drop(4, function(param){return cs;}), 0)]
            : word(modl, cs);
   }
   function fals(modl, cs){
    var _fB_ = to_seq$0(_dy_);
    return 0
            ===
             compare
              (function(a, b){return a === b ? 0 : 1;},
               take(5, function(param){return cs;}),
               _fB_)
            ? [0,
              _dz_,
              modl,
              caml_call1(drop(5, function(param){return cs;}), 0)]
            : word(modl, cs);
   }
   function word(modl, cs){
    function inn(modl, cs$0){
     if(! cs$0) return [0, 0, modl, cs$0, 0];
     var e = cs$0[1];
     a:
     {
      b:
      {
       if(33 > e){
        var _fA_ = e - 9 | 0;
        if(1 < _fA_ >>> 0){if(23 > _fA_) break a;} else if(_fA_) break b;
        var cs$3 = cs$0[2];
        return [0, 0, modl, caml_call1(cs$3, 0), 0];
       }
       var switcher = e - 58 | 0;
       if(1 < switcher >>> 0){
        if(35 !== switcher) break a;
       }
       else if(! switcher){
        var cs$2 = cs$0[2], match = caml_call1(cs$2, 0);
        c:
        {
         if(match){
          var _fw_ = match[1];
          if(9 !== _fw_ && 32 !== _fw_){var _fx_ = 0; break c;}
         }
         var _fx_ = 1;
        }
        if(_fx_) return [0, 0, modl, caml_call1(cs$2, 0), 1];
        var match$0 = caml_call1(cs$2, 0);
        c:
        {
         d:
         if(match$0){
          var _fy_ = match$0[1] - 10 | 0;
          if(49 < _fy_ >>> 0){
           if(83 !== _fy_) break d;
          }
          else if(47 >= _fy_ - 1 >>> 0) break d;
          var _fz_ = 1;
          break c;
         }
         var _fz_ = 0;
        }
        if(_fz_) return [0, 0, modl, caml_call1(cs$2, 0), 1];
        var
         param$0 = inn(modl, caml_call1(cs$2, 0)),
         d = param$0[4],
         c = param$0[3],
         b = param$0[2],
         a = param$0[1];
        return [0, [0, 0, function(param){return a;}], b, c, d];
       }
      }
      return [0, 0, modl, cs$0, 0];
     }
     var
      cs$1 = cs$0[2],
      param = inn(modl, caml_call1(cs$1, 0)),
      d$0 = param[4],
      c$0 = param[3],
      b$0 = param[2],
      a$0 = param[1];
     if(a$0)
      var
       cs = a$0[2],
       c$1 = a$0[1],
       _fv_ = [0, [0, e, function(param){return c$1;}], cs];
     else
      var _fv_ = [0, [0, e, empty], empty];
     return [0, _fv_, b$0, c$0, d$0];
    }
    var param = inn(modl, cs), cs$0 = param[1];
    if(cs$0){
     var c = cs$0[1];
     if(! c){
      var cs$2 = cs$0[2];
      if(0 === cs$2(0)) return parse_err(modl, _dB_);
     }
     var rest = param[3], modl$0 = param[2], cs$1 = cs$0[2];
     if(param[4]){
      if(0 === cs$1(0))
       return build
               (59,
                function(lst){
                 var _fu_ = rev(lst);
                 return [4, of_seq(function(param){return c;}), _fu_];
                },
                modl$0,
                function(param){return rest;});
     }
     else if(0 === cs$1(0))
      return [0, [1, of_seq(function(param){return c;})], modl$0, rest];
    }
    var rest$0 = param[3], modl$1 = param[2];
    function seq$0(param){return cs$0;}
    var acc = 0, seq = seq$0;
    for(;;){
     var match = seq(0);
     if(! match){
      if(! acc) return parse_err(modl$1, _dA_);
      var ws = acc[2], w = acc[1];
      return [0, [5, ws, w], modl$1, rest$0];
     }
     var next = match[2], x = match[1];
     let x$0 = x;
     var acc$0 = [0, of_seq(function(param){return x$0;}), acc];
     acc = acc$0;
     seq = next;
    }
   }
   function build(ch, f, modl, cs){
    function inn(acc, modl){
     function stream(f, acc, cs){
      var
       param = caml_call2(f, modl, cs),
       cs$0 = param[3],
       modl$0 = param[2],
       tok = param[1];
      return uncurry3(inn, [0, [0, tok, acc], modl$0, cs$0]);
     }
     return function(cs){
      if(! cs){
       var s1 = make$0(1, ch), s2 = s1 + '", not EOF';
       return parse_err(modl, 'Expected end character "' + s2);
      }
      var c = cs[1], cs$0 = cs[2];
      if(c === ch){
       var _fi_ = caml_call1(cs$0, 0);
       return [0, rev(acc), modl, _fi_];
      }
      if(59 <= c){
       if(91 === c){
        var cs$1 = cs[2], _fj_ = function(lst){return [2, lst];}, _fk_ = 93;
        return stream
                (function(_fp_, _fq_){return build(_fk_, _fj_, _fp_, _fq_);},
                 acc,
                 cs$1);
       }
       if(102 === c) return stream(fals, acc, cs);
       if(116 === c) return stream(tru, acc, cs);
      }
      else if(32 <= c){
       if(48 <= c){
        if(58 > c) return stream(int$0, acc, cs);
        var
         cs$2 = cs[2],
         _fl_ =
           function(param){
            if(! param) return parse_err(modl, _dC_);
            var lst = param[2], t = param[1], _ft_ = rev(lst);
            return [3, string_of_tok(t), 0, _ft_];
           },
         _fm_ = 59;
        return stream
                (function(_fr_, _fs_){return build(_fm_, _fl_, _fr_, _fs_);},
                 acc,
                 cs$2);
       }
       if(41 > c)
        switch(c - 32 | 0){
          case 0:
           var cs$3 = cs[2], _fn_ = caml_call1(cs$3, 0);
           return inn(acc, modl)(_fn_);
          case 2:
           var cs$4 = cs[2]; return stream(str, acc, cs$4);
          case 8:
           var cs$5 = cs[2]; return stream(comm, acc, cs$5);
        }
      }
      else if(10 === c){
       var cs$6 = cs[2], _fo_ = caml_call1(cs$6, 0);
       return inn(acc, incl(modl))(_fo_);
      }
      return stream(word, acc, cs);};
    }
    var _fh_ = caml_call1(cs, 0);
    return map_a3(f, inn(0, modl)(_fh_));
   }
   function parse(modl){
    function stream(f, cs){
     var
      param = caml_call2(f, modl, cs),
      cs$0 = param[3],
      modl$0 = param[2],
      tok = param[1],
      a = eval$1(modl$0)(tok);
     return parse(a)(cs$0);
    }
    return function(cs){
     if(! cs) return modl;
     var _e7_ = cs[1];
     if(59 <= _e7_){
      if(91 === _e7_){
       var cs$0 = cs[2], _e8_ = function(lst){return [2, lst];}, _e9_ = 93;
       return stream
               (function(_fc_, _fd_){return build(_e9_, _e8_, _fc_, _fd_);},
                cs$0);
      }
      if(102 === _e7_) return stream(fals, cs);
      if(116 === _e7_) return stream(tru, cs);
     }
     else if(32 <= _e7_){
      if(48 <= _e7_){
       if(58 > _e7_) return stream(int$0, cs);
       var
        cs$1 = cs[2],
        _e__ =
          function(param){
           if(! param) return parse_err(modl, _dD_);
           var lst = param[2], t = param[1], _fg_ = rev(lst);
           return [3, string_of_tok(t), 0, _fg_];
          },
        _e$_ = 59;
       return stream
               (function(_fe_, _ff_){return build(_e$_, _e__, _fe_, _ff_);},
                cs$1);
      }
      if(41 > _e7_)
       switch(_e7_ - 32 | 0){
         case 0:
          var cs$2 = cs[2], _fa_ = caml_call1(cs$2, 0);
          return parse(modl)(_fa_);
         case 2:
          var cs$3 = cs[2]; return stream(str, cs$3);
         case 8:
          var cs$4 = cs[2]; return stream(comm, cs$4);
       }
     }
     else if(10 === _e7_){
      var cs$5 = cs[2], _fb_ = caml_call1(cs$5, 0);
      return parse(incl(modl))(_fb_);
     }
     return stream(word, cs);};
   }
   function eval$1(modl){
    function eval_list(modl){
     return function(_e6_){return fold_left(eval$1, modl, _e6_);};
    }
    function stl(param){
     if(param){
      var x = param[1];
      if(param[2]){var xs = param[2]; return [0, x, stl(xs)];}
     }
     return 0;
    }
    return function(x){
     switch(x[0]){
       case 0:
        push(x, stack); return modl;
       case 1:
        var def_name = x[1], lst$0 = modl[2];
        a:
        {
         b:
         {
          var param$0 = lst$0;
          for(;;){
           if(! param$0) break;
           var
            l$0 = param$0[2],
            a$0 = param$0[1][1],
            _ew_ = 0 === caml_compare(a$0, def_name) ? 1 : 0;
           if(_ew_) break b;
           param$0 = l$0;
          }
          var _ex_ = 0;
          break a;
         }
         var _ex_ = _ew_;
        }
        if(! _ex_){
         var switch$4 = caml_string_compare(def_name, cst_dup);
         if(0 <= switch$4){
          if(0 >= switch$4){
           var x$2 = top(modl, def_name);
           push(x$2, stack);
           return modl;
          }
          var switch$5 = caml_string_compare(def_name, cst_over);
          if(0 <= switch$5){
           if(0 >= switch$5){
            var a$4 = pop(modl, def_name), b$2 = top(modl, def_name);
            push(a$4, stack);
            push(b$2, stack);
            return modl;
           }
           if(def_name === cst_pop){pop(modl, def_name); return modl;}
           if(def_name === cst_quote){
            var x$0 = [2, [0, pop(modl, def_name), 0]];
            push(x$0, stack);
            return modl;
           }
           if(def_name === cst_rot){
            var
             a$3 = pop(modl, def_name),
             b$1 = pop(modl, def_name),
             c = pop(modl, def_name);
            push(b$1, stack);
            push(a$3, stack);
            push(c, stack);
            return modl;
           }
           if(def_name === cst_shd)
            return match_nonempty_quote
                    (function(q){
                      var _eH_ = hd(rev(q));
                      return eval$1(modl)(_eH_);
                     },
                     modl,
                     def_name);
           if(def_name === cst_stl)
            return match_nonempty_quote
                    (function(q){
                      var _eG_ = [2, stl(q)];
                      return eval$1(modl)(_eG_);
                     },
                     modl,
                     def_name);
           if(def_name === cst_swap){
            var a$2 = pop(modl, def_name), b$0 = pop(modl, def_name);
            push(a$2, stack);
            push(b$0, stack);
            return modl;
           }
           if(def_name === cst_tl)
            return match_nonempty_quote
                    (function(q){
                      if(q) var l = q[2], _eF_ = l; else var _eF_ = failwith(_q_);
                      return eval$1(modl)([2, _eF_]);
                     },
                     modl,
                     def_name);
           if(def_name === cst_use)
            return match_str
                    (function(s){return use(modl, eval_file(s));},
                     modl,
                     def_name);
           if(def_name === cst_useup)
            return match_str
                    (function(s){return useup(modl, eval_file(s));},
                     modl,
                     def_name);
          }
          else{
           var switch$6 = caml_string_compare(def_name, cst_len);
           if(0 <= switch$6){
            if(0 >= switch$6){
             var x$1 = [0, [0, stack[2]]];
             push(x$1, stack);
             return modl;
            }
            if(def_name === cst_not){
             match_bool
              (function(x){
                var x$0 = [0, [2, 1 - x]];
                return push(x$0, stack);
               },
               modl,
               def_name);
             return modl;
            }
            if(def_name === cst_open)
             return match_quote(eval_list(modl), modl, def_name);
            if(def_name === cst_or){
             bop
              (function(_eK_, _eJ_){var _eL_ = _eK_ || _eJ_; return _eL_;},
               modl,
               def_name);
             return modl;
            }
            if(def_name === cst_outfile)
             return match_str
                     (function(name){
                       var
                        _eI_ = string_of_tok(pop(modl, def_name)),
                        c =
                          caml_ml_open_descriptor_out(caml_sys_open(name, mode, 438));
                       caml_ml_set_channel_name(c, name);
                       output_string(c, _eI_);
                       return modl;
                      },
                      modl,
                      def_name);
           }
           else{
            if(def_name === cst_eval)
             return match_str
                     (function(s){
                       var _eN_ = to_seq$0(s)(0);
                       return parse(modl)(_eN_);
                      },
                      modl,
                      def_name);
            if(def_name === cst_exit)
             throw caml_maybe_attach_backtrace(Exit, 1);
            if(def_name === cst_hd)
             return match_nonempty_quote
                     (function(q){var _eM_ = hd(q); return eval$1(modl)(_eM_);},
                      modl,
                      def_name);
            if(def_name === cst_if)
             return match_quote
                     (function(f){
                       return match_quote
                               (function(t){
                                 return match_bool
                                         (function(b){
                                           return b ? eval_list(modl)(t) : eval_list(modl)(f);
                                          },
                                          modl,
                                          def_name);
                                },
                                modl,
                                def_name);
                      },
                      modl,
                      def_name);
            if(def_name === cst_infile)
             return match_str
                     (function(s){
                       var x = [0, [1, input_all(open_text(s))]];
                       push(x, stack);
                       return modl;
                      },
                      modl,
                      def_name);
           }
          }
         }
         else{
          var switch$7 = caml_string_compare(def_name, cst$19);
          if(0 <= switch$7){
           if(0 >= switch$7){
            isbqop_bool
             (function(_e1_, _e0_){return _e1_ !== _e0_ ? 1 : 0;},
              function(x, y){return 1 - (x === y ? 1 : 0);},
              function(_eZ_, _eY_){return _eZ_ !== _eY_ ? 1 : 0;},
              function(x, y){
               return 0 !== compare$0(caml_compare, x, y) ? 1 : 0;
              },
              modl,
              def_name);
            return modl;
           }
           if(def_name === cst$20){
            isbqop_bool
             (function(_eX_, _eW_){return _eX_ === _eW_ ? 1 : 0;},
              caml_string_equal,
              function(_eV_, _eU_){return _eV_ === _eU_ ? 1 : 0;},
              function(x, y){
               return 0 === compare$0(caml_compare, x, y) ? 1 : 0;
              },
              modl,
              def_name);
            return modl;
           }
           if(def_name === cst$15){
            isop_bool
             (function(_eT_, _eS_){return _eS_ < _eT_ ? 1 : 0;},
              function(x, y){return 1 === caml_string_compare(x, y) ? 1 : 0;},
              modl,
              def_name);
            return modl;
           }
           if(def_name === cst_and){
            bop
             (function(_eQ_, _eP_){
               var _eR_ = _eQ_ ? _eP_ : _eQ_;
               return _eR_;
              },
              modl,
              def_name);
            return modl;
           }
           if(def_name === cst_bind)
            return match_nonempty_quote
                    (function(q){
                      if(q){
                       var _eO_ = q[1];
                       if(1 === _eO_[0]){
                        var n = _eO_[1];
                        if(! q[2])
                         return add$0(modl, [0, n, [0, [2, [0, [1, n], 0]], 0]]);
                        var ts = q[2];
                        return add$0(modl, [0, n, ts]);
                       }
                      }
                      return eval_err(modl, _dN_);
                     },
                     modl,
                     def_name);
           if(def_name === cst_chars)
            return match_str
                    (function(s){
                      var
                       match$2 =
                         map
                          (function(c){return [0, [1, make$0(1, c)]];},
                           to_seq$0(s),
                           0);
                      if(match$2){
                       var seq = match$2[2], x1 = match$2[1], match = seq(0);
                       if(match){
                        var
                         seq$0 = match[2],
                         x2 = match[1],
                         block = [0, x2, 24029],
                         dst = block,
                         offset = 1,
                         seq$1 = seq$0;
                        for(;;){
                         var match$0 = seq$1(0);
                         if(match$0){
                          var
                           seq$2 = match$0[2],
                           x1$0 = match$0[1],
                           match$1 = seq$2(0);
                          if(match$1){
                           var
                            seq$3 = match$1[2],
                            x2$0 = match$1[1],
                            dst$0 = [0, x2$0, 24029];
                           dst[1 + offset] = [0, x1$0, dst$0];
                           dst = dst$0;
                           offset = 1;
                           seq$1 = seq$3;
                           continue;
                          }
                          dst[1 + offset] = [0, x1$0, 0];
                         }
                         else
                          dst[1 + offset] = 0;
                         var x = [0, x1, block];
                         break;
                        }
                       }
                       else
                        var x = [0, x1, 0];
                      }
                      else
                       var x = 0;
                      var x$0 = [2, x];
                      push(x$0, stack);
                      return modl;
                     },
                     modl,
                     def_name);
           if(def_name === cst_concat)
            return match_quote
                    (function(q){
                      var
                       s =
                         concat
                          (_dM_,
                           map$0
                            (function(param){
                              if(0 === param[0]){
                               var match = param[1];
                               if(1 === match[0]){var s = match[1]; return s;}
                              }
                              return eval_err(modl, _dL_);
                             },
                             q)),
                       x = [0, [1, s]];
                      push(x, stack);
                      return modl;
                     },
                     modl,
                     def_name);
           if(def_name === cst_del)
            return match_str
                    (function(def_name){
                      var
                       i = modl[5],
                       out = modl[4],
                       modls = modl[3],
                       lst = modl[2],
                       name = modl[1];
                      return [0, name, remove_assoc(def_name, lst), modls, out, i];
                     },
                     modl,
                     def_name);
           if(def_name === "desc"){
            var match$3 = pop(modl, def_name);
            a:
            {
             b:
             {
              switch(match$3[0]){
                case 0:
                 var _eB_ = match$3[1];
                 if(1 !== _eB_[0]) break b;
                 var n$0 = _eB_[1];
                 break;
                case 2:
                 var _eC_ = match$3[1];
                 if(! _eC_) break b;
                 var _eD_ = _eC_[1];
                 if(1 !== _eD_[0]) break b;
                 if(_eC_[2]) break b;
                 var n$0 = _eD_[1];
                 break;
                default: break b;
              }
              var match$4 = find_opt(modl, n$0);
              if(match$4){
               var ts$0 = match$4[1], x$3 = [2, ts$0];
               push(x$3, stack);
              }
              else{var x$4 = [0, [1, n$0]]; push(x$4, stack);}
              break a;
             }
             eval_err(modl, _dK_);
            }
            return modl;
           }
           if(def_name === cst_describe){
            var match$1 = pop(modl, def_name);
            a:
            {
             b:
             {
              switch(match$1[0]){
                case 0:
                 var _ey_ = match$1[1];
                 if(1 !== _ey_[0]) break b;
                 var name$0 = _ey_[1];
                 break;
                case 2:
                 var _ez_ = match$1[1];
                 if(! _ez_) break b;
                 var _eA_ = _ez_[1];
                 if(1 !== _eA_[0]) break b;
                 if(_ez_[2]) break b;
                 var name$0 = _eA_[1];
                 break;
                default: break b;
              }
              var match$2 = find_opt(modl, name$0);
              if(match$2){
               var ts = match$2[1];
               print_fun(0, 0)(ts);
              }
              else{
               var switch$0 = caml_string_compare(name$0, cst_eval);
               c:
               {
                if(0 <= switch$0){
                 if(0 >= switch$0){var typ = _c9_; break c;}
                 var switch$1 = caml_string_compare(name$0, cst_over);
                 if(0 <= switch$1){
                  if(0 >= switch$1){var typ = _cZ_; break c;}
                  if(name$0 === cst_pop){var typ = _cY_; break c;}
                  if(name$0 === cst_quote){var typ = _cX_; break c;}
                  if(name$0 === cst_rot){var typ = _cW_; break c;}
                  if(name$0 === cst_shd){var typ = _cV_; break c;}
                  if(name$0 === cst_stl){var typ = _cU_; break c;}
                  if(name$0 === cst_swap){var typ = _cT_; break c;}
                  if(name$0 === cst_tl){var typ = _cS_; break c;}
                  if(name$0 === cst_use){var typ = _cR_; break c;}
                  if(name$0 === cst_useup){var typ = _cQ_; break c;}
                 }
                 else{
                  if(name$0 === cst_exit){var typ = _c8_; break c;}
                  if(name$0 === cst_hd){var typ = _c7_; break c;}
                  if(name$0 === cst_if){var typ = _c6_; break c;}
                  if(name$0 === cst_infile){var typ = _c5_; break c;}
                  if(name$0 === cst_len){var typ = _c4_; break c;}
                  if(name$0 === cst_not){var typ = _c3_; break c;}
                  if(name$0 === cst_open){var typ = _c2_; break c;}
                  if(name$0 === cst_or){var typ = _c1_; break c;}
                  if(name$0 === cst_outfile){var typ = _c0_; break c;}
                 }
                }
                else{
                 var switch$2 = caml_string_compare(name$0, cst$19);
                 if(0 <= switch$2){
                  if(0 >= switch$2){var typ = _dh_; break c;}
                  if(name$0 === cst$20){var typ = _dg_; break c;}
                  if(name$0 === cst$15){var typ = _df_; break c;}
                  if(name$0 === cst_and){var typ = _de_; break c;}
                  if(name$0 === cst_bind){var typ = _dd_; break c;}
                  if(name$0 === cst_chars){var typ = _dc_; break c;}
                  if(name$0 === cst_concat){var typ = _db_; break c;}
                  if(name$0 === cst_del){var typ = _da_; break c;}
                  if(name$0 === cst_describe){var typ = _c$_; break c;}
                  if(name$0 === cst_dup){var typ = _c__; break c;}
                 }
                 else{
                  var switch$3 = caml_string_compare(name$0, cst$21);
                  if(0 <= switch$3){
                   if(0 >= switch$3){var typ = _dm_; break c;}
                   if(name$0 === cst$22){var typ = _dl_; break c;}
                   if(name$0 === cst$3){var typ = _dk_; break c;}
                   if(name$0 === cst$5){var typ = _dj_; break c;}
                   if(name$0 === cst$16){var typ = _di_; break c;}
                  }
                  else{
                   if(name$0 === cst$23){var typ = _dr_; break c;}
                   if(name$0 === cst$24){var typ = _dq_; break c;}
                   if(name$0 === cst$25){var typ = _dp_; break c;}
                   if(name$0 === cst$26){var typ = _do_; break c;}
                   if(name$0 === cst_quote$0){var typ = _dn_; break c;}
                  }
                 }
                }
                var
                 s2$4 = name$0 + " description not found",
                 typ = eval_err(modl, cst_Function + s2$4);
               }
               var
                s2$3 = typ + cst$11,
                s2$2 = cst$10 + s2$3,
                s2$1 = name$0 + s2$2,
                s$0 = "Core:" + s2$1;
               output_string(stdout, s$0);
              }
              break a;
             }
             eval_err(modl, _dJ_);
            }
            return modl;
           }
          }
          else{
           var switch$8 = caml_string_compare(def_name, cst$21);
           if(0 <= switch$8){
            if(0 >= switch$8){
             caml_ml_flush(stdout);
             var
              build_result =
                function(buf, pos, param){
                 var pos$0 = pos, param$0 = param;
                 for(;;){
                  if(! param$0) return buf;
                  var
                   tl = param$0[2],
                   hd = param$0[1],
                   len = caml_ml_bytes_length(hd);
                  caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
                  var pos$1 = pos$0 - len | 0;
                  pos$0 = pos$1;
                  param$0 = tl;
                 }
                },
              accu = 0,
              len = 0;
             for(;;){
              var n = caml_ml_input_scan_line(stdin);
              if(0 === n){
               if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
               var _ev_ = build_result(caml_create_bytes(len), len, accu);
              }
              else{
               if(0 >= n){
                var beg = caml_create_bytes(- n | 0);
                caml_ml_input(stdin, beg, 0, - n | 0);
                var len$1 = len - n | 0, accu$0 = [0, beg, accu];
                accu = accu$0;
                len = len$1;
                continue;
               }
               var res = caml_create_bytes(n - 1 | 0);
               caml_ml_input(stdin, res, 0, n - 1 | 0);
               caml_ml_input_char(stdin);
               if(accu)
                var
                 len$0 = (len + n | 0) - 1 | 0,
                 _ev_ =
                   build_result
                    (caml_create_bytes(len$0), len$0, [0, res, accu]);
               else
                var _ev_ = res;
              }
              var x$5 = [0, [1, caml_string_of_bytes(_ev_)]];
              push(x$5, stack);
              return modl;
             }
            }
            if(def_name === cst$22){
             iop
              (function(_e5_, _e4_){return _e5_ - _e4_ | 0;}, modl, def_name);
             return modl;
            }
            if(def_name === cst$3){
             var
              s1 = string_of_tok(pop(modl, def_name)),
              _eE_ =
                ends_with(_dE_, s1)
                 ? s1
                 : ends_with
                    (_dF_, s1)
                   ? s1
                   : ends_with
                      (_dG_, s1)
                     ? s1
                     : ends_with
                        (_dH_, s1)
                       ? s1
                       : ends_with(_dI_, s1) ? s1 : s1 + cst$7;
             return add_out(modl, _eE_);
            }
            if(def_name === cst$5){
             iop(caml_div, modl, def_name);
             return modl;
            }
            if(def_name === cst$16){
             isop_bool
              (function(_e3_, _e2_){return _e3_ < _e2_ ? 1 : 0;},
               function(x, y){
                return -1 === caml_string_compare(x, y) ? 1 : 0;
               },
               modl,
               def_name);
             return modl;
            }
           }
           else{
            if(def_name === cst$23){
             iop(caml_mod, modl, def_name);
             return modl;
            }
            if(def_name === cst$24){
             iop(caml_mul, modl, def_name);
             return modl;
            }
            if(def_name === cst$25){iop(pow, modl, def_name); return modl;}
            if(def_name === cst$26){
             var a$1 = pop(modl, def_name);
             a:
             {
              switch(a$1[0]){
                case 0:
                 var match$0 = a$1[1];
                 switch(match$0[0]){
                   case 0:
                    var y = match$0[1];
                    match_int
                     (function(x){
                       var x$0 = [0, [0, x + y | 0]];
                       return push(x$0, stack);
                      },
                      modl,
                      def_name);
                    break a;
                   case 1:
                    var s2 = match$0[1];
                    match_str
                     (function(s1){
                       var x = [0, [1, s1 + s2]];
                       return push(x, stack);
                      },
                      modl,
                      def_name);
                    break a;
                 }
                 break;
                case 2:
                 var q = a$1[1];
                 match_quote
                  (function(e){
                    var x = [2, symbol(e, q)];
                    return push(x, stack);
                   },
                   modl,
                   def_name);
                 break a;
              }
              var s2$5 = def_name + cst_expected_either_Ints_or_St;
              err(a$1, modl, cst_Function + s2$5);
             }
             return modl;
            }
            if(def_name === cst_quote$0){
             match_quote
              (function(q){
                var x = [2, [0, pop(modl, def_name), q]];
                return push(x, stack);
               },
               modl,
               def_name);
             return modl;
            }
           }
          }
         }
         var s2$0 = def_name + cst$18;
         return eval_err(modl, 'Undefined Word "' + s2$0);
        }
        var lst = modl[2], param = lst;
        for(;;){
         if(! param) throw caml_maybe_attach_backtrace(Not_found, 1);
         var l = param[2], match = param[1], b = match[2], a = match[1];
         if(0 === caml_compare(a, def_name)){
          var
           print = eval_list(modl)(b)[4],
           i = modl[5],
           modls = modl[3],
           lst$1 = modl[2],
           name = modl[1];
          return [0, name, lst$1, modls, print, i];
         }
         param = l;
        }
        break;
       case 2:
        push(x, stack); return modl;
       case 3:
        var
         ts$1 = x[3],
         n$1 = x[1],
         ts$2 =
           fold_left
            (function(acc, a){
              if(1 === a[0] && a[1] === cst_take)
               return [0, pop(modl, _dO_), acc];
              return [0, a, acc];
             },
             0,
             ts$1);
        return add$0(modl, [0, n$1, ts$2]);
       case 4:
        var
         ts$3 = x[2],
         n$2 = x[1],
         fold_right =
           function(f, l, accu){
            if(! l) return accu;
            var l$0 = l[2], a = l[1];
            return caml_call2(f, a, fold_right(f, l$0, accu));
           };
        return use
                (modl,
                 fold_right
                  (function(x, y){return eval$1(y)(x);},
                   ts$3,
                   useup(create$2(n$2), modl)));
       case 5:
        var
         s = x[2],
         sl = x[1],
         m = fold_left(find_modl, modl, rev(sl)),
         out = eval$1(m)([1, s])[4];
        return add_out(modl, out);
       default: return modl;
     }};
   }
   function eval_file(filename$0){
    var
     l$0 = extension_len(filename$0),
     _et_ =
       0 === l$0
        ? _co_
        : sub$0(filename$0, caml_ml_string_length(filename$0) - l$0 | 0, l$0),
     filename$1 = _et_ === cst_fthish ? filename$0 : filename$0 + cst_fthish;
    if(caml_sys_file_exists(filename$1))
     var input = open_text(filename$1);
    else{
     a:
     {
      b:
      {
       var param = forthish_std;
       for(;;){
        if(! param) break;
        var
         l = param[2],
         dir = param[1],
         filename = concat$0(dir, filename$1),
         result = caml_sys_file_exists(filename) ? [0, filename] : 0;
        if(result) break b;
        param = l;
       }
       var match = 0;
       break a;
      }
      var match = result;
     }
     if(! match){
      var s2 = filename$1 + " not found";
      throw caml_maybe_attach_backtrace
             ([0, Eval_err, "File " + s2, create$2(_dP_)], 1);
     }
     var f = match[1], input = open_text(f);
    }
    var
     x = input_all(input),
     _eu_ = to_seq$0(x)(0),
     name = basename$2(filename$0),
     l$1 = extension_len(name),
     s =
       0 === l$1
        ? name
        : sub$0(name, 0, caml_ml_string_length(name) - l$1 | 0),
     s$0 = caml_bytes_of_string(s);
    if(0 === caml_ml_bytes_length(s$0))
     var _es_ = s$0;
    else{
     var len = caml_ml_bytes_length(s$0), r = caml_create_bytes(len);
     caml_blit_bytes(s$0, 0, r, 0, len);
     caml_bytes_unsafe_set
      (r, 0, uppercase_ascii(caml_bytes_unsafe_get(s$0, 0)));
     var _es_ = r;
    }
    return parse(create$2(caml_string_of_bytes(_es_)))(_eu_);
   }
   var Error = [248, _dQ_, caml_fresh_oo_id(0)];
   register_exception(_dR_, [0, Error, [0]]);
   (function(exn){throw exn;});
   var global = globalThis, no_handler = null, undefined$0 = undefined;
   function test(x){return 1 - (x === undefined$0 ? 1 : 0);}
   var true$0 = true, false$0 = false;
   global.String;
   var regExp = global.RegExp;
   global.Object;
   var array_constructor = global.Array;
   global.Date;
   global.Math;
   global.Error;
   global.JSON;
   register_printer
    (function(param){
      if(param[1] !== Error) return 0;
      var t14 = param[2];
      return [0, caml_string_of_jsstring(t14.toString())];
     });
   register_printer
    (function(t25){
      return t25 instanceof array_constructor
              ? 0
              : [0, caml_string_of_jsstring(t25.toString())];
     });
   function handler(f){
    return caml_js_wrap_callback_unsafe
            (function(t19){
              if(1 - (t19 == no_handler ? 1 : 0)){
               var res = caml_call1(f, t19);
               if(1 - (res | 0)) t19.preventDefault();
               return res;
              }
              var t18 = event, res$0 = caml_call1(f, t18);
              if(1 - (res$0 | 0)) t18.returnValue = res$0;
              return res$0;
             });
   }
   function addEventListener(t28, typ, t44, capt){
    if(test(t28.addEventListener)){
     var opts = {};
     opts.capture = capt;
     t28.addEventListener(typ, t44, opts);
     return;
    }
    var t31 = "on".concat(typ);
    function callback(e){
     var _ep_ = [0, t44, e, [0]];
     return function(_eq_, _er_){return caml_js_call(_ep_, _eq_, _er_);};
    }
    t28.attachEvent(t31, callback);
   }
   global.ArrayBuffer;
   global.Int8Array;
   global.Uint8Array;
   global.Int16Array;
   global.Uint16Array;
   global.Int32Array;
   global.Uint32Array;
   global.Float32Array;
   global.Float64Array;
   global.DataView;
   global.Blob;
   global.Document;
   global.FileReader;
   var
    mousedown = "mousedown",
    keydown = "keydown",
    document = global.document,
    html_element = global.HTMLElement;
   test(html_element);
   global.FormData;
   global.FormData;
   global.Worker;
   global.WebSocket;
   ({alpha: true$0,
     depth: true$0,
     stencil: false$0,
     antialias: true$0,
     premultipliedAlpha: false$0,
     preserveDrawingBuffer: false$0,
     preferLowPowerToHighPerformance: false$0,
     failIfMajorPerformanceCaveat: false$0});
   function regexp(s){
    var t0 = caml_jsbytes_of_string(s);
    return new regExp(t0, cst_g);
   }
   new regExp("[$]", cst_g);
   var quote_re = regexp(_dS_), Local_exn = [248, _dT_, caml_fresh_oo_id(0)];
   function interrupt(param){throw caml_maybe_attach_backtrace(Local_exn, 1);}
   regexp(caml_string_of_jsbytes(cst$26.replace(quote_re, "\\$&")));
   var plus_re_js_string = new regExp("\\+", cst_g);
   function urldecode_js_string_string(t16){
    plus_re_js_string.lastIndex = 0;
    var s = t16.replace(plus_re_js_string, cst$7);
    return caml_string_of_jsbytes(global.unescape(s));
   }
   new
    regExp
    ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$");
   new regExp("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$");
   if(test(global.location))
    var t43 = global.location;
   else
    var
     t42 = function(_eo_, param){return 0;},
     t41 = function(_en_, param){return 0;},
     t40 = function(param){return 0;},
     t43 =
       {href: cst,
        protocol: cst,
        host: cst,
        hostname: cst,
        port: cst,
        pathname: cst,
        search: cst,
        hash: cst,
        origin: undefined$0,
        reload: caml_js_wrap_meth_callback(t40),
        replace: caml_js_wrap_meth_callback(t41),
        assign: caml_js_wrap_meth_callback(t42)};
   urldecode_js_string_string(t43.hostname);
   urldecode_js_string_string(t43.protocol);
   try{caml_int_of_string(caml_string_of_jsbytes(t43.port));}
   catch(_em_){
    var _dV_ = caml_wrap_exception(_em_);
    if(_dV_[1] !== Failure) throw caml_maybe_attach_backtrace(_dV_, 0);
   }
   var
    path_string = urldecode_js_string_string(t43.pathname),
    l$1 = caml_ml_string_length(path_string);
   function aux(i){
    try{var _ek_ = index_from(path_string, i, 47), j = _ek_;}
    catch(_el_){
     var _ej_ = caml_wrap_exception(_el_);
     if(_ej_ !== Not_found) throw caml_maybe_attach_backtrace(_ej_, 0);
     var j = l$1;
    }
    var word = sub$0(path_string, i, j - i | 0);
    return l$1 <= j ? [0, word, 0] : [0, word, aux(j + 1 | 0)];
   }
   var a = aux(0);
   a:
   if(a && a[1] === cst){
    var _dU_ = a[2];
    if(! _dU_ || _dU_[1] === cst && ! _dU_[2]) break a;
   }
   var t49 = t43.search;
   if(t49.charAt(0) == "?")
    var t52 = t43.search, t1 = t52.slice(1);
   else
    var t1 = t43.search;
   var
    t0 = caml_jsstring_of_string(make$0(1, 38)),
    arr = t1.split(t0),
    len = arr.length;
   function aux$0(acc, idx){
    var idx$0 = idx;
    for(;;){
     if(0 > idx$0) return acc;
     try{
      var t3 = arr[idx$0], _ef_ = idx$0 - 1 | 0;
      if(t3 === undefined$0)
       var _eh_ = interrupt(0);
      else{
       var
        t2 = caml_jsstring_of_string(make$0(1, 61)),
        index = t3.indexOf(t2);
       if(0 <= index)
        var
         t7 = index + 1 | 0,
         _ed_ = t3.slice(t7),
         x$0 = [0, t3.slice(0, index), _ed_];
       else
        var x$0 = undefined$0;
       if(x$0 === undefined$0)
        var _ec_ = interrupt(0);
       else
        var
         y = x$0[2],
         x = x$0[1],
         _eg_ = urldecode_js_string_string(y),
         _ec_ = [0, urldecode_js_string_string(x), _eg_];
       var _eh_ = _ec_;
      }
      aux$0([0, _eh_, acc], _ef_);
      return;
     }
     catch(_ei_){
      var _ee_ = caml_wrap_exception(_ei_);
      if(_ee_ !== Local_exn) throw caml_maybe_attach_backtrace(_ee_, 0);
      var idx$1 = idx$0 - 1 | 0;
      idx$0 = idx$1;
     }
    }
   }
   aux$0(0, len - 1 | 0);
   urldecode_js_string_string(t43.href);
   global.ResizeObserver;
   global.PerformanceObserver;
   global.MutationObserver;
   global.Object;
   global.JSON;
   global.SVGElement;
   global.document;
   global.EventSource;
   global.EventSource;
   var t1$0 = global.navigator;
   if(test(t1$0)) t1$0.geolocation;
   global.IntersectionObserver;
   global.Intl;
   var t52$0 = global.Intl;
   t52$0.Collator;
   var t54 = global.Intl;
   t54.DateTimeFormat;
   var t56 = global.Intl;
   t56.NumberFormat;
   var t58 = global.Intl;
   t58.PluralRules;
   function run(modl, str){
    try{
     a:
     if(str === cst)
      var s$3 = str;
     else{
      if
       (!
        is_space$0(caml_string_unsafe_get(str, 0))
        &&
         !
         is_space$0
          (caml_string_unsafe_get(str, caml_ml_string_length(str) - 1 | 0))){var s$3 = str; break a;}
      var
       s$4 = caml_bytes_of_string(str),
       len = caml_ml_bytes_length(s$4),
       i = [0, 0];
      for(;;){
       if(i[1] >= len) break;
       if(! is_space(caml_bytes_unsafe_get(s$4, i[1]))) break;
       i[1]++;
      }
      var j = [0, len - 1 | 0];
      for(;;){
       if(i[1] > j[1]) break;
       if(! is_space(caml_bytes_unsafe_get(s$4, j[1]))) break;
       j[1]--;
      }
      var
       _d$_ =
         i[1] <= j[1] ? sub(s$4, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty$0,
       s$3 = caml_string_of_bytes(_d$_);
     }
     var
      _eb_ = to_seq$0(s$3)(0),
      param = parse(modl)(_eb_),
      i$0 = param[5],
      out = param[4],
      modls = param[3],
      fns = param[2],
      name = param[1],
      _ea_ = [0, out, [0, name, fns, modls, _dW_, i$0]];
     return _ea_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Eval_err){var s = exn[2]; return [0, s, modl];}
     if(exn[1] === Parse_err){var s$0 = exn[2]; return [0, s$0, modl];}
     if(exn[1] === Sys_error){var s$1 = exn[2]; return [0, s$1, modl];}
     if(exn[1] !== Failure)
      return exn === End_of_file
              ? [0, _dX_, modl]
              : exn
                === Not_found
                ? [0, _dY_, modl]
                : exn
                  === Empty
                  ? [0, _dZ_, modl]
                  : exn
                    === Division_by_zero
                    ? [0, _d0_, modl]
                    : exn === Exit ? [0, _d1_, modl] : [0, _d2_, modl];
     var s$2 = exn[2];
     return [0, s$2, modl];
    }
   }
   function onload(param){
    var parent = document.getElementById("history");
    if(parent == no_handler)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d3_], 1);
    var interp = document.getElementById("interpreter");
    if(interp == no_handler)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d4_], 1);
    interp.focus();
    var modl = [0, create$2(_d5_)], m = run(modl[1], std_lib)[2];
    modl[1] = m;
    addEventListener
     (interp,
      keydown,
      handler
       (function(t14){
         var match$0 = t14.keyCode;
         if(13 === match$0){
          var x = interp.textContent, match = x == no_handler ? 0 : [0, x];
          if(match){
           var
            t9 = match[1],
            match$1 = run(modl[1], caml_string_of_jsstring(t9)),
            m = match$1[2],
            res = match$1[1];
           modl[1] = m;
           var
            t10 = caml_jsstring_of_string("<br/>" + res),
            text = "> ".concat(t9, t10),
            div = document.createElement("div");
           div.innerHTML = text;
           parent.appendChild(div);
           interp.textContent = cst;
          }
          return false$0;
         }
         if(76 === match$0 && t14.ctrlKey | 0){
          parent.textContent = cst;
          return false$0;
         }
         return true$0;
        }),
      true$0);
    addEventListener
     (document,
      mousedown,
      handler(function(param){interp.focus(); return false$0;}),
      true$0);
    return false$0;
   }
   var t18 = handler(onload);
   global.onload = t18;
   do_at_exit(0);
   return;
  }
  (globalThis));

//# sourceMappingURL=main.map
